#!/usr/bin/env bun
/**
 * Brain API MCP Server for Claude Code
 *
 * An MCP (Model Context Protocol) server that exposes Brain API tools to Claude Code.
 * This allows Claude Code to use brain_save, brain_recall, brain_search, etc.
 *
 * Configuration:
 * - BRAIN_API_URL: Base URL for the Brain API (default: http://localhost:3333)
 *
 * This file is auto-generated by brain. Do not edit directly.
 * Source: https://github.com/huynle/brain
 * Generated: {{GENERATED_DATE}}
 *
 * Usage:
 *   Add to your Claude Code MCP config:
 *   {
 *     "mcpServers": {
 *       "brain": {
 *         "command": "bun",
 *         "args": ["run", "/path/to/brain-mcp.ts"],
 *         "env": { "BRAIN_API_URL": "http://localhost:3333" }
 *       }
 *     }
 *   }
 */

import { execSync } from "child_process";
import { homedir } from "os";

// ============================================================================
// Types
// ============================================================================

type BrainEntryType =
  | "summary"
  | "report"
  | "walkthrough"
  | "plan"
  | "pattern"
  | "learning"
  | "idea"
  | "scratch"
  | "decision"
  | "exploration"
  | "execution"
  | "task";

type BrainEntryStatus =
  | "draft"
  | "pending"
  | "active"
  | "in_progress"
  | "blocked"
  | "completed"
  | "validated"
  | "superseded"
  | "archived";

const ENTRY_TYPES: BrainEntryType[] = [
  "summary", "report", "walkthrough", "plan", "pattern", "learning",
  "idea", "scratch", "decision", "exploration", "execution", "task",
];

const ENTRY_STATUSES: BrainEntryStatus[] = [
  "draft", "pending", "active", "in_progress", "blocked",
  "completed", "validated", "superseded", "archived",
];

type BrainPriority = "high" | "medium" | "low";

const PRIORITIES: BrainPriority[] = ["high", "medium", "low"];

// ============================================================================
// Configuration
// ============================================================================

const BRAIN_API_URL = process.env.BRAIN_API_URL || "http://localhost:3333";

// ============================================================================
// Health Check & Connection State
// ============================================================================

interface BrainConnectionState {
  available: boolean;
  lastCheck: number;
  lastError?: string;
  version?: string;
}

let connectionState: BrainConnectionState = {
  available: false,
  lastCheck: 0,
};

const HEALTH_CHECK_INTERVAL_MS = 30_000; // Re-check every 30 seconds when healthy
const HEALTH_CHECK_RETRY_MS = 5_000; // Re-check every 5 seconds when unhealthy (faster reconnect)

async function checkBrainHealth(): Promise<BrainConnectionState> {
  const now = Date.now();
  
  // Use shorter retry interval when unhealthy for faster reconnect
  const cacheInterval = connectionState.available 
    ? HEALTH_CHECK_INTERVAL_MS 
    : HEALTH_CHECK_RETRY_MS;
  
  if (now - connectionState.lastCheck < cacheInterval) {
    return connectionState;
  }

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    
    const response = await fetch(`${BRAIN_API_URL}/api/v1/health`, {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    if (response.ok) {
      const data = await response.json();
      connectionState = {
        available: true,
        lastCheck: now,
        version: data.version,
      };
    } else {
      connectionState = {
        available: false,
        lastCheck: now,
        lastError: `Server returned ${response.status}: ${response.statusText}`,
      };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionRefused = errorMessage.includes("ECONNREFUSED") || 
                                 errorMessage.includes("fetch failed") ||
                                 errorMessage.includes("aborted");
    
    connectionState = {
      available: false,
      lastCheck: now,
      lastError: isConnectionRefused 
        ? `Cannot connect to Brain API at ${BRAIN_API_URL}. Start with: brain start`
        : `Health check failed: ${errorMessage}`,
    };
  }

  return connectionState;
}

function formatUnavailableMessage(): string {
  return `BRAIN API UNAVAILABLE

The Brain API server is not reachable at ${BRAIN_API_URL}.
Error: ${connectionState.lastError || "Unknown error"}

To fix: Run "brain start" to start the server.
Brain tools will not work until the server is running.`;
}

// ============================================================================
// Execution Context
// ============================================================================

interface ExecutionContext {
  projectId: string;
  workdir: string;
  gitRemote?: string;
  gitBranch?: string; // Used to derive worktree path
}

function getExecutionContext(directory: string): ExecutionContext {
  const home = homedir();
  let mainRepoPath = directory;
  let gitRemote: string | undefined;
  let gitBranch: string | undefined;

  try {
    const worktreeList = execSync("git worktree list --porcelain", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    const lines = worktreeList.split("\n");
    const firstWorktreeLine = lines.find((l) => l.startsWith("worktree "));
    if (firstWorktreeLine) {
      mainRepoPath = firstWorktreeLine.replace("worktree ", "");
    }

    gitRemote = execSync("git remote get-url origin", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    gitBranch = execSync("git branch --show-current", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();
  } catch {
    // Not a git repo
  }

  const makeHomeRelative = (path: string): string => {
    if (path.startsWith(home)) {
      return path.slice(home.length + 1);
    }
    return path;
  };

  return {
    projectId: makeHomeRelative(mainRepoPath),
    workdir: makeHomeRelative(mainRepoPath),
    gitRemote,
    gitBranch,
  };
}

// ============================================================================
// API Client
// ============================================================================

interface ApiError {
  error: string;
  message: string;
  details?: unknown;
}

async function apiRequest<T>(
  method: string,
  path: string,
  body?: unknown,
  queryParams?: Record<string, string | number | boolean | undefined>
): Promise<T> {
  // Check health before making request
  const health = await checkBrainHealth();
  if (!health.available) {
    throw new Error(formatUnavailableMessage());
  }

  let url = `${BRAIN_API_URL}/api/v1${path}`;

  if (queryParams) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(queryParams)) {
      if (value !== undefined) {
        params.append(key, String(value));
      }
    }
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }
  }

  const options: RequestInit = {
    method,
    headers: { "Content-Type": "application/json" },
  };

  if (body && (method === "POST" || method === "PATCH" || method === "PUT")) {
    options.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url, options);

    if (!response.ok) {
      let errorData: ApiError;
      try {
        errorData = await response.json();
      } catch {
        errorData = {
          error: "API Error",
          message: `HTTP ${response.status}: ${response.statusText}`,
        };
      }
      throw new Error(errorData.message || `API error: ${response.status}`);
    }

    return response.json();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionError = errorMessage.includes("ECONNREFUSED") || 
                              errorMessage.includes("fetch failed");
    
    if (isConnectionError) {
      connectionState = {
        available: false,
        lastCheck: Date.now(),
        lastError: `Connection lost: ${errorMessage}`,
      };
      throw new Error(formatUnavailableMessage());
    }
    
    throw error;
  }
}

// ============================================================================
// MCP Protocol Types
// ============================================================================

interface MCPRequest {
  jsonrpc: "2.0";
  id: number | string;
  method: string;
  params?: unknown;
}

interface MCPResponse {
  jsonrpc: "2.0";
  id: number | string;
  result?: unknown;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

interface MCPNotification {
  jsonrpc: "2.0";
  method: string;
  params?: unknown;
}

interface Tool {
  name: string;
  description: string;
  inputSchema: {
    type: "object";
    properties: Record<string, unknown>;
    required?: string[];
  };
}

// ============================================================================
// Tool Definitions
// ============================================================================

const tools: Tool[] = [
  {
    name: "brain_save",
    description: `Save content to the brain for future reference. Use this to persist:
- summaries: Session summaries, key decisions made
- reports: Analysis reports, code reviews, investigations
- walkthroughs: Code explanations, architecture overviews
- plans: Implementation plans, designs, roadmaps
- patterns: Reusable patterns discovered (use global:true for cross-project)
- learnings: General learnings, best practices (use global:true for cross-project)
- ideas: Ideas for future exploration
- scratch: Temporary working notes
- decision: Architectural decisions, ADRs
- exploration: Investigation notes, research findings`,
    inputSchema: {
      type: "object",
      properties: {
        type: { type: "string", enum: ENTRY_TYPES, description: "Type of content being saved" },
        title: { type: "string", description: "Short descriptive title for the entry" },
        content: { type: "string", description: "The content to save (markdown supported)" },
        tags: { type: "array", items: { type: "string" }, description: "Tags for categorization" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Initial status. Tasks default to 'draft' (user reviews before promoting to 'pending'). Other entry types default to 'active'." },
        priority: { type: "string", enum: ["high", "medium", "low"], description: "Priority level" },
        global: { type: "boolean", description: "Save to global brain (cross-project)" },
        project: { type: "string", description: "Explicit project ID/name" },
        depends_on: { type: "array", items: { type: "string" }, description: "Task dependencies - list of task IDs or titles" },
        user_original_request: { type: "string", description: "Verbatim user request for this task. HIGHLY RECOMMENDED for tasks - enables validation during task completion. Supports multiline content, code blocks, and special characters. When creating multiple tasks from one user request, include this in EACH task." },
        target_workdir: { type: "string", description: "Explicit working directory override for task execution (absolute path). When set, the task runner will try this directory first before falling back to workdir resolution. Use for tasks that should execute in a specific directory." },
        feature_id: { type: "string", description: "Feature group ID for this task (e.g., 'auth-system', 'payment-flow'). Tasks with the same feature_id are grouped together for ordered execution." },
        feature_priority: { type: "string", enum: ["high", "medium", "low"], description: "Priority level for the feature group. Determines execution order relative to other features." },
        feature_depends_on: { type: "array", items: { type: "string" }, description: "Feature IDs this feature depends on. All tasks in dependent features must complete before this feature's tasks can start." },
      },
      required: ["type", "title", "content"],
    },
  },
  {
    name: "brain_recall",
    description: "Retrieve a specific entry from the brain by path, ID, or title.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path or ID to the note" },
        title: { type: "string", description: "Title to search for (exact match)" },
      },
    },
  },
  {
    name: "brain_search",
    description: "Search the brain using full-text search.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "Search query" },
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Filter by status" },
        feature_id: { type: "string", description: "Filter by feature group ID (e.g., 'auth-system', 'dark-mode')" },
        limit: { type: "number", description: "Maximum results (default: 10)" },
        global: { type: "boolean", description: "Search only global entries" },
      },
      required: ["query"],
    },
  },
  {
    name: "brain_list",
    description: `List entries in the brain with optional filtering by type, status, and filename.

Filename filtering supports:
- Exact match: "abc12def" finds entry with that exact ID
- Wildcard patterns: "abc*" (prefix), "*def" (suffix), "abc*def" (contains)`,
    inputSchema: {
      type: "object",
      properties: {
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Filter by status" },
        feature_id: { type: "string", description: "Filter by feature group ID (e.g., 'auth-system', 'dark-mode')" },
        limit: { type: "number", description: "Maximum entries to return (default: 20)" },
        global: { type: "boolean", description: "List only global entries" },
        sortBy: { type: "string", enum: ["created", "modified", "priority"], description: "Sort order" },
        filename: { type: "string", description: "Filter by filename/ID (supports wildcards: abc*, *def, abc*def)" },
      },
    },
  },
  {
    name: "brain_inject",
    description: "Search the brain and return relevant context for a task.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "What context are you looking for?" },
        maxEntries: { type: "number", description: "Maximum entries to include (default: 5)" },
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
      },
      required: ["query"],
    },
  },
  {
    name: "brain_update",
    description: `Update an existing brain entry's status, title, dependencies, or append content.

Use cases:
- Mark a plan as completed: brain_update(path: "...", status: "completed")
- Mark as in-progress: brain_update(path: "...", status: "in_progress")  
- Block with reason: brain_update(path: "...", status: "blocked", note: "Waiting on API design")
- Append progress notes: brain_update(path: "...", append: "## Progress\\n- Completed auth module")
- Update title: brain_update(path: "...", title: "New Title")
- Update dependencies: brain_update(path: "...", depends_on: ["task-id-1", "task-id-2"])

Statuses: draft, active, in_progress, blocked, completed, validated, superseded, archived`,
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the entry to update" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "New status" },
        title: { type: "string", description: "New title" },
        append: { type: "string", description: "Content to append" },
        note: { type: "string", description: "Short note to add" },
        depends_on: { type: "array", items: { type: "string" }, description: "Task dependencies - list of task IDs or titles" },
        feature_id: { type: "string", description: "Feature group identifier (e.g., 'auth-system', 'payment-flow')" },
        feature_priority: { type: "string", enum: PRIORITIES, description: "Priority for this feature group" },
        feature_depends_on: { type: "array", items: { type: "string" }, description: "Feature IDs this feature depends on" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_stats",
    description: "Get statistics about the brain storage.",
    inputSchema: {
      type: "object",
      properties: {
        global: { type: "boolean", description: "Show only global entries stats" },
      },
    },
  },
  {
    name: "brain_check_connection",
    description: `Check if the Brain API server is running and accessible.

Use this tool FIRST if you're unsure whether brain tools will work.
Returns connection status, server version, and helpful troubleshooting info if unavailable.

This is useful to:
- Verify the brain is available before starting a task that needs it
- Diagnose why other brain tools are failing
- Get instructions for starting the brain server`,
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "brain_tasks",
    description: `List all tasks for current project with dependency status (ready/waiting/blocked), stats, and cycles detected.

Use this to see:
- Which tasks are ready to work on (dependencies met)
- Which tasks are waiting (dependencies incomplete)
- Which tasks are blocked (circular deps or blocked deps)
- Overall task queue stats`,
    inputSchema: {
      type: "object",
      properties: {
        status: { type: "string", enum: ENTRY_STATUSES, description: "Filter by task status (pending, in_progress, completed, etc.)" },
        classification: { type: "string", enum: ["ready", "waiting", "blocked"], description: "Filter by dependency classification" },
        feature_id: { type: "string", description: "Filter tasks by feature group ID (e.g., 'auth-system', 'dark-mode')" },
        limit: { type: "number", description: "Maximum results to return (default: 50)" },
        project: { type: "string", description: "Override auto-detected project" },
      },
    },
  },
  {
    name: "brain_task_next",
    description: `Get the next actionable task (highest priority ready task) with full content.

Use this to quickly find what to work on next. Returns the complete task including:
- Full markdown content for implementation
- User's original request for validation
- Dependency information

If no ready tasks, shows current queue state.`,
    inputSchema: {
      type: "object",
      properties: {
        project: { type: "string", description: "Override auto-detected project" },
      },
    },
  },
  {
    name: "brain_task_get",
    description: `Get a specific task by ID with full dependency info, dependents list, and content.

Use this to get detailed information about a specific task including:
- Full markdown content for implementation
- User's original request for validation  
- Dependencies (what this task needs)
- Dependents (what needs this task)
- Classification (ready/waiting/blocked)`,
    inputSchema: {
      type: "object",
      properties: {
        taskId: { type: "string", description: "Task ID (8-char alphanumeric) or title" },
        project: { type: "string", description: "Override auto-detected project" },
      },
      required: ["taskId"],
    },
  },
  {
    name: "brain_tasks_status",
    description: `Get status of multiple tasks by ID, with optional blocking wait.

Use cases:
- Check if spawned subtasks are complete before continuing
- Wait for dependent tasks to finish before starting next phase
- Monitor multiple tasks from an orchestrator agent

Parameters:
- taskIds: Array of task IDs (8-char alphanumeric) to check
- waitFor: Optional. "completed" (default) waits until all tasks completed/validated.
           "any" returns as soon as any task status changes.
           Omit for immediate response without waiting.
- timeout: Max wait time in milliseconds (default: 60000, max: 300000)
- project: Override auto-detected project

Example - immediate check:
  brain_tasks_status({ taskIds: ["abc12def", "xyz98765"] })

Example - wait for completion:
  brain_tasks_status({ taskIds: ["abc12def"], waitFor: "completed", timeout: 120000 })`,
    inputSchema: {
      type: "object",
      properties: {
        taskIds: { 
          type: "array", 
          items: { type: "string" }, 
          description: "Array of task IDs (8-char alphanumeric) to check" 
        },
        waitFor: { 
          type: "string", 
          enum: ["completed", "any"], 
          description: "Wait condition: 'completed' waits for all done, 'any' waits for any change" 
        },
        timeout: { 
          type: "number", 
          description: "Max wait time in milliseconds (default: 60000, max: 300000)" 
        },
        project: { 
          type: "string", 
          description: "Override auto-detected project" 
        },
      },
      required: ["taskIds"],
    },
  },
  {
    name: "brain_backlinks",
    description: "Find entries that link TO a given entry (backlinks).",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the target note" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_outlinks",
    description: "Find entries that a given entry links TO (outlinks).",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the source note" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_related",
    description: "Find entries that share linked notes with a given entry.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the note to find related entries for" },
        limit: { type: "number", description: "Maximum results (default: 10)" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_orphans",
    description: "Find entries with no incoming links (orphans). Useful for knowledge graph health.",
    inputSchema: {
      type: "object",
      properties: {
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        limit: { type: "number", description: "Maximum results (default: 20)" },
      },
    },
  },
  {
    name: "brain_stale",
    description: "Find entries that may need verification (not verified in N days).",
    inputSchema: {
      type: "object",
      properties: {
        days: { type: "number", description: "Days threshold (default: 30)" },
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        limit: { type: "number", description: "Maximum results (default: 20)" },
      },
    },
  },
  {
    name: "brain_verify",
    description: "Mark an entry as verified (still accurate). Updates the last_verified timestamp.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the note to verify" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_delete",
    description: "Delete a specific entry from the brain by path. Use with caution.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the entry to delete" },
        confirm: { type: "boolean", description: "Must be true to confirm deletion" },
      },
      required: ["path", "confirm"],
    },
  },
  {
    name: "brain_link",
    description: "Generate a markdown link to a brain entry. Use this when referencing other brain entries to ensure proper link resolution with mkdnflow.",
    inputSchema: {
      type: "object",
      properties: {
        title: { type: "string", description: "Title to search for" },
        path: { type: "string", description: "Direct path or ID (8-char alphanumeric) to the entry" },
        withTitle: { type: "boolean", description: "Include title in link (default: true)" },
      },
    },
  },
  {
    name: "brain_section",
    description: `Retrieve a specific section's FULL CONTENT from a brain plan by section title.

Use this when you need the detailed implementation spec for your assigned task.
Returns the exact section content including all subsections, code examples, and acceptance criteria.

Example: brain_section({ planId: "projects/abc/plan/auth.md", sectionTitle: "JWT Middleware" })

This is more precise than brain_inject (which uses fuzzy search) - it extracts the exact section you need.`,
    inputSchema: {
      type: "object",
      properties: {
        planId: { type: "string", description: "Brain plan path (from orchestration context or brain_plan_sections)" },
        sectionTitle: { type: "string", description: "Section title to retrieve (can be partial match)" },
        includeSubsections: { type: "boolean", description: "Include nested subsections (default: true)" },
      },
      required: ["planId", "sectionTitle"],
    },
  },
  {
    name: "brain_plan_sections",
    description: "Extract section headers from a plan entry for orchestration mapping.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the plan entry" },
        title: { type: "string", description: "Title to search for" },
      },
    },
  },
];

// ============================================================================
// Tool Handlers
// ============================================================================

const context = getExecutionContext(process.cwd());

async function handleToolCall(name: string, args: Record<string, unknown>): Promise<string> {
  try {
    switch (name) {
      case "brain_save": {
        const response = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          link: string;
        }>("POST", "/entries", {
          ...args,
          project: args.project || context.projectId,
          target_workdir: args.type === "task" ? args.target_workdir : undefined,
          workdir: args.type === "task" ? context.workdir : undefined,
          git_remote: args.type === "task" ? context.gitRemote : undefined,
          git_branch: args.type === "task" ? context.gitBranch : undefined,
          // Only include user_original_request for tasks
          user_original_request:
            args.type === "task" ? args.user_original_request : undefined,
          // Feature grouping for tasks
          feature_id: args.type === "task" ? args.feature_id : undefined,
          feature_priority: args.type === "task" ? args.feature_priority : undefined,
          feature_depends_on: args.type === "task" ? args.feature_depends_on : undefined,
        });
        return `Saved to brain\n\nPath: ${response.path}\nID: ${response.id}\nTitle: ${response.title}\nType: ${response.type}\nStatus: ${response.status}`;
      }

      case "brain_recall": {
        let entryPath = args.path as string | undefined;
        if (!entryPath && args.title) {
          const searchResult = await apiRequest<{
            results: Array<{ path: string; title: string }>;
          }>("POST", "/search", { query: args.title, limit: 5 });
          const exactMatch = searchResult.results.find((r) => r.title === args.title);
          if (exactMatch) {
            entryPath = exactMatch.path;
          } else {
            return `No exact match for: "${args.title}"`;
          }
        }
        if (!entryPath) return "Please provide a path or title";
        
        const response = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          content: string;
          tags: string[];
          user_original_request?: string;
        }>("GET", `/entries/${entryPath}`);
        const userRequest = response.user_original_request ? `\nUser Original Request: ${response.user_original_request}` : "";
        return `## ${response.title}\n\nPath: ${response.path}\nType: ${response.type}\nStatus: ${response.status}\nTags: ${response.tags?.join(", ") || "none"}${userRequest}\n\n---\n\n${response.content}`;
      }

      case "brain_search": {
        const response = await apiRequest<{
          results: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
            status: string;
            snippet: string;
          }>;
          total: number;
        }>("POST", "/search", args);
        if (response.results.length === 0) {
          return `No entries found matching "${args.query}"`;
        }
        const lines = [`Found ${response.total} entries:\n`];
        for (const result of response.results) {
          lines.push(`- **${result.title}** (${result.path}) - ${result.type}`);
          if (result.snippet) lines.push(`  > ${result.snippet}...`);
        }
        return lines.join("\n");
      }

      case "brain_list": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
            status: string;
            priority?: string;
          }>;
          total: number;
        }>("GET", "/entries", undefined, args as Record<string, string | number | boolean | undefined>);
        if (response.entries.length === 0) {
          return "No entries found";
        }
        const lines = [`Found ${response.total} entries:\n`];
        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (${entry.path}) - ${entry.type} | ${entry.status}`);
        }
        return lines.join("\n");
      }

      case "brain_inject": {
        const response = await apiRequest<{
          context: string;
          entries: Array<{ id: string; path: string; title: string; type: string }>;
        }>("POST", "/inject", args);
        if (!response.context || response.entries.length === 0) {
          return `No relevant context found for "${args.query}"`;
        }
        return response.context;
      }

      case "brain_update": {
        const response = await apiRequest<{
          path: string;
          title: string;
          status: string;
        }>("PATCH", `/entries/${args.path}`, args);
        return `Updated: ${response.path}\nStatus: ${response.status}\nTitle: ${response.title}`;
      }

      case "brain_stats": {
        const response = await apiRequest<{
          totalEntries: number;
          globalEntries: number;
          projectEntries: number;
          byType: Record<string, number>;
        }>("GET", "/stats", undefined, args as Record<string, string | number | boolean | undefined>);
        const lines = [
          "## Brain Statistics\n",
          `Total: ${response.totalEntries}`,
          `Global: ${response.globalEntries}`,
          `Project: ${response.projectEntries}`,
          "\n### By Type",
        ];
        for (const [type, count] of Object.entries(response.byType).sort((a, b) => b[1] - a[1])) {
          lines.push(`- ${type}: ${count}`);
        }
        return lines.join("\n");
      }

      case "brain_check_connection": {
        // Force a fresh health check
        connectionState.lastCheck = 0;
        const health = await checkBrainHealth();

        if (health.available) {
          return `Brain API Status: CONNECTED

Server URL: ${BRAIN_API_URL}
Version: ${health.version || "unknown"}
Status: Ready to use

All brain tools (save, recall, search, inject, etc.) are available.`;
        } else {
          return `Brain API Status: UNAVAILABLE

Server URL: ${BRAIN_API_URL}
Error: ${health.lastError || "Unknown error"}

To start the Brain API server:
  brain start

To check server status:
  brain status

Brain tools will not work until the server is running.`;
        }
      }

      case "brain_tasks": {
        const proj = (args.project as string) || context.projectId;
        
        interface TaskWithDeps {
          id: string;
          title: string;
          status: string;
          priority?: string;
          feature_id?: string;
          classification: string;
          dependsOn?: Array<{ id: string; title: string; status: string }>;
          blockedBy?: string;
        }
        
        interface TaskListResponse {
          tasks: TaskWithDeps[];
          count: number;
          stats?: {
            ready: number;
            waiting: number;
            blocked: number;
            completed: number;
            total: number;
          };
          cycles?: Array<{ taskId: string; cycle: string[] }>;
        }
        
        const response = await apiRequest<TaskListResponse>(
          "GET",
          `/tasks/${encodeURIComponent(proj)}`
        );

        // Apply filters
        let filteredTasks = response.tasks;
        
        if (args.status) {
          filteredTasks = filteredTasks.filter(t => t.status === args.status);
        }
        
        if (args.classification) {
          filteredTasks = filteredTasks.filter(t => t.classification === args.classification);
        }
        
        if (args.feature_id) {
          filteredTasks = filteredTasks.filter(t => t.feature_id === args.feature_id);
        }
        
        const limit = (args.limit as number) ?? 50;
        filteredTasks = filteredTasks.slice(0, limit);

        // Group by classification
        const ready = filteredTasks.filter(t => t.classification === "ready");
        const waiting = filteredTasks.filter(t => t.classification === "waiting");
        const blocked = filteredTasks.filter(t => t.classification === "blocked");

        const lines: string[] = [];
        lines.push(`## Tasks for project: ${proj}`);
        lines.push("");

        // Stats summary
        if (response.stats) {
          const s = response.stats;
          lines.push(`**Stats:** ${s.ready} ready | ${s.waiting} waiting | ${s.blocked} blocked | ${s.completed} completed`);
          lines.push("");
        }

        // Ready tasks
        if (ready.length > 0) {
          lines.push("### Ready (can start now)");
          for (const task of ready) {
            const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
            lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
            if (task.dependsOn && task.dependsOn.length > 0) {
              const deps = task.dependsOn.map(d => `${d.title} (${d.status})`).join(", ");
              lines.push(`  Dependencies: ${deps}`);
            } else {
              lines.push("  Dependencies: none");
            }
          }
          lines.push("");
        }

        // Waiting tasks
        if (waiting.length > 0) {
          lines.push("### Waiting (deps incomplete)");
          for (const task of waiting) {
            const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
            lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
            if (task.dependsOn && task.dependsOn.length > 0) {
              const incomplete = task.dependsOn.filter(d => d.status !== "completed");
              const deps = incomplete.map(d => `${d.title} (${d.status})`).join(", ");
              lines.push(`  Waiting on: ${deps}`);
            }
          }
          lines.push("");
        }

        // Blocked tasks
        if (blocked.length > 0) {
          lines.push("### Blocked");
          for (const task of blocked) {
            const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
            lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
            lines.push(`  Blocked by: ${task.blockedBy || "circular dependency or blocked deps"}`);
          }
          lines.push("");
        }

        // Cycles warning
        if (response.cycles && response.cycles.length > 0) {
          lines.push("### Circular Dependencies Detected");
          for (const cycle of response.cycles) {
            lines.push(`- Cycle: ${cycle.cycle.join(" -> ")}`);
          }
          lines.push("");
        }

        if (filteredTasks.length === 0) {
          lines.push("*No tasks found matching criteria.*");
        }

        return lines.join("\n");
      }

      case "brain_task_next": {
        const proj = (args.project as string) || context.projectId;
        
        // Get next ready task from API
        interface TaskNextResponse {
          task: {
            id: string;
            path: string;
            title: string;
            status: string;
            priority?: string;
            classification: string;
            resolved_deps: string[];
            waiting_on: string[];
            blocked_by: string[];
            user_original_request?: string;
          } | null;
          message?: string;
        }
        
        const response = await apiRequest<TaskNextResponse>(
          "GET",
          `/tasks/${encodeURIComponent(proj)}/next`
        );

        // No ready task available
        if (!response.task) {
          // Get stats for context
          interface TaskListResponse {
            tasks: Array<{ classification: string; status: string }>;
            stats?: {
              ready: number;
              waiting: number;
              blocked: number;
              completed: number;
              total: number;
            };
          }
          
          const statsResponse = await apiRequest<TaskListResponse>(
            "GET",
            `/tasks/${encodeURIComponent(proj)}`
          );
          
          const stats = statsResponse.stats || {
            ready: 0,
            waiting: statsResponse.tasks.filter(t => t.classification === "waiting").length,
            blocked: statsResponse.tasks.filter(t => t.classification === "blocked").length,
            completed: statsResponse.tasks.filter(t => t.status === "completed").length,
            total: statsResponse.tasks.length,
          };

          return `No ready tasks available.

Current state:
- ${stats.waiting} tasks waiting on dependencies
- ${stats.blocked} tasks blocked
- ${stats.completed} tasks completed

Use brain_tasks to see the full task list and dependency status.`;
        }

        const task = response.task;
        
        // Get full entry content
        const entry = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          content: string;
          tags: string[];
          user_original_request?: string;
        }>("GET", `/entries/${task.path}`);

        const priority = task.priority === "high" ? "HIGH" : task.priority === "medium" ? "MEDIUM" : "LOW";
        const depsCount = task.resolved_deps?.length || 0;
        
        const lines: string[] = [];
        lines.push(`## Next Task: ${entry.title}`);
        lines.push("");
        lines.push(`**ID:** ${entry.id}`);
        lines.push(`**Path:** ${entry.path}`);
        lines.push(`**Priority:** ${priority}`);
        lines.push(`**Status:** ${entry.status}`);
        lines.push("");
        
        // User's original request for validation
        if (entry.user_original_request) {
          lines.push("### User Original Request");
          lines.push(`> ${entry.user_original_request.split('\n').join('\n> ')}`);
          lines.push("");
        }
        
        lines.push("### Quick Context");
        if (depsCount > 0) {
          lines.push(`- ${depsCount} dependencies (all satisfied)`);
        } else {
          lines.push("- No dependencies");
        }
        lines.push("");
        lines.push("---");
        lines.push("");
        lines.push(entry.content);

        return lines.join("\n");
      }

      case "brain_task_get": {
        if (!args.taskId) {
          return "Please provide a task ID or title";
        }

        const proj = (args.project as string) || context.projectId;
        
        // Get all tasks to find the specific task and calculate dependents
        interface TaskWithDeps {
          id: string;
          title: string;
          path: string;
          status: string;
          priority?: string;
          classification: string;
          resolved_deps: string[];
          waiting_on: string[];
          blocked_by: string[];
          dependsOn?: Array<{ id: string; title: string; status: string }>;
        }
        
        interface TaskListResponse {
          tasks: TaskWithDeps[];
          count: number;
        }
        
        const tasksResponse = await apiRequest<TaskListResponse>(
          "GET",
          `/tasks/${encodeURIComponent(proj)}`
        );

        // Find the task by ID or title
        const taskIdLower = (args.taskId as string).toLowerCase();
        const task = tasksResponse.tasks.find(
          t => t.id.toLowerCase() === taskIdLower || 
               t.title.toLowerCase() === taskIdLower
        );

        if (!task) {
          // Try searching for partial match
          const partialMatches = tasksResponse.tasks.filter(
            t => t.title.toLowerCase().includes(taskIdLower) ||
                 t.id.toLowerCase().includes(taskIdLower)
          );
          
          if (partialMatches.length > 0) {
            const suggestions = partialMatches.slice(0, 5).map(
              t => `- ${t.title} (ID: ${t.id})`
            ).join("\n");
            return `Task not found: "${args.taskId}"\n\nDid you mean:\n${suggestions}`;
          }
          
          return `Task not found: "${args.taskId}"\n\nUse brain_tasks to list all tasks.`;
        }

        // Calculate dependents - tasks that have this task in their resolved_deps
        const dependents = tasksResponse.tasks.filter(
          t => t.resolved_deps?.includes(task.id)
        ).map(t => ({
          id: t.id,
          title: t.title,
          status: t.status,
        }));

        // Get full entry content
        const entry = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          content: string;
          tags: string[];
          user_original_request?: string;
        }>("GET", `/entries/${task.path}`);

        const priority = task.priority === "high" ? "HIGH" : task.priority === "medium" ? "MEDIUM" : "LOW";
        
        const lines: string[] = [];
        lines.push(`## ${entry.title}`);
        lines.push("");
        lines.push(`**ID:** ${entry.id}`);
        lines.push(`**Path:** ${entry.path}`);
        lines.push(`**Priority:** ${priority}`);
        lines.push(`**Status:** ${entry.status}`);
        lines.push(`**Classification:** ${task.classification}`);
        lines.push("");
        
        // Dependencies section
        lines.push("### Dependencies (what this task needs)");
        if (task.dependsOn && task.dependsOn.length > 0) {
          for (const dep of task.dependsOn) {
            const statusEmoji = dep.status === "completed" ? "✓" : dep.status === "in_progress" ? "⋯" : "○";
            lines.push(`- ${statusEmoji} **${dep.title}** (${dep.id}) - ${dep.status}`);
          }
        } else {
          lines.push("*No dependencies*");
        }
        lines.push("");
        
        // Dependents section
        lines.push("### Dependents (what needs this task)");
        if (dependents.length > 0) {
          for (const dep of dependents) {
            const statusEmoji = dep.status === "completed" ? "✓" : dep.status === "in_progress" ? "⋯" : "○";
            lines.push(`- ${statusEmoji} **${dep.title}** (${dep.id}) - ${dep.status}`);
          }
        } else {
          lines.push("*No tasks depend on this one*");
        }
        lines.push("");
        
        // User's original request
        if (entry.user_original_request) {
          lines.push("### User Original Request");
          lines.push(`> ${entry.user_original_request.split('\n').join('\n> ')}`);
          lines.push("");
        }
        
        lines.push("---");
        lines.push("");
        lines.push(entry.content);

        return lines.join("\n");
      }

      case "brain_tasks_status": {
        const taskIds = args.taskIds as string[];
        if (!taskIds || taskIds.length === 0) {
          return "Please provide at least one task ID";
        }

        const proj = (args.project as string) || context.projectId;
        const waitFor = args.waitFor as "completed" | "any" | undefined;
        const timeout = Math.min((args.timeout as number) || 60000, 300000);

        interface TaskStatusResponse {
          tasks: Array<{
            id: string;
            title: string;
            status: string;
            priority?: string;
            classification: string;
          }>;
          notFound: string[];
          changed: boolean;
          timedOut: boolean;
        }

        const response = await apiRequest<TaskStatusResponse>(
          "POST",
          `/tasks/${encodeURIComponent(proj)}/status`,
          {
            taskIds,
            waitFor,
            timeout,
          }
        );

        const lines: string[] = [];
        lines.push(`## Task Status Check`);
        lines.push("");

        if (response.timedOut) {
          lines.push("**Status:** Timed out waiting for condition");
          lines.push("");
        } else if (response.changed) {
          lines.push("**Status:** Condition met");
          lines.push("");
        } else {
          lines.push("**Status:** Immediate check (no wait)");
          lines.push("");
        }

        // Show task statuses
        if (response.tasks.length > 0) {
          lines.push("### Tasks");
          for (const task of response.tasks) {
            const statusEmoji = 
              task.status === "completed" || task.status === "validated" ? "✓" :
              task.status === "in_progress" ? "⋯" :
              task.status === "blocked" ? "✗" : "○";
            const priority = task.priority === "high" ? "[HIGH]" : 
                             task.priority === "medium" ? "[MED]" : "[LOW]";
            lines.push(`- ${statusEmoji} **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
          }
          lines.push("");
        }

        // Show not found tasks
        if (response.notFound.length > 0) {
          lines.push("### Not Found");
          for (const id of response.notFound) {
            lines.push(`- \`${id}\` - task not found`);
          }
          lines.push("");
        }

        // Summary
        const completed = response.tasks.filter(t => 
          t.status === "completed" || t.status === "validated"
        ).length;
        const total = response.tasks.length;
        lines.push(`**Summary:** ${completed}/${total} tasks completed`);

        return lines.join("\n");
      }

      case "brain_backlinks": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
          }>;
          total: number;
        }>("GET", `/entries/${args.path}/backlinks`);

        if (response.entries.length === 0) {
          return `No backlinks found for: ${args.path}`;
        }

        const lines = [
          `## Backlinks to: ${args.path}`,
          "",
          `Found ${response.total} entries linking to this note:`,
          "",
        ];

        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`);
        }

        return lines.join("\n");
      }

      case "brain_outlinks": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
          }>;
          total: number;
        }>("GET", `/entries/${args.path}/outlinks`);

        if (response.entries.length === 0) {
          return `No outlinks found from: ${args.path}`;
        }

        const lines = [
          `## Outlinks from: ${args.path}`,
          "",
          `Found ${response.total} entries linked from this note:`,
          "",
        ];

        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`);
        }

        return lines.join("\n");
      }

      case "brain_related": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
          }>;
          total: number;
        }>("GET", `/entries/${args.path}/related`, undefined, {
          limit: (args.limit as number) ?? 10,
        });

        if (response.entries.length === 0) {
          return `No related entries found for: ${args.path}`;
        }

        const lines = [
          `## Related to: ${args.path}`,
          "",
          `Found ${response.total} entries sharing links:`,
          "",
        ];

        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`);
        }

        return lines.join("\n");
      }

      case "brain_orphans": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
          }>;
          total: number;
        }>("GET", "/orphans", undefined, {
          type: args.type as string | undefined,
          limit: (args.limit as number) ?? 20,
        });

        if (response.entries.length === 0) {
          return `No orphan entries found${args.type ? ` of type "${args.type}"` : ""}`;
        }

        const lines = [
          `## Orphan Entries${args.type ? ` (${args.type})` : ""}`,
          "",
          `Found ${response.total} entries with no incoming links:`,
          "",
        ];

        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`);
        }

        lines.push("");
        lines.push("*Consider linking these notes from related entries to improve knowledge graph connectivity.*");

        return lines.join("\n");
      }

      case "brain_stale": {
        const days = (args.days as number) ?? 30;

        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
            daysSinceVerified: number | null;
          }>;
          total: number;
        }>("GET", "/stale", undefined, {
          days,
          type: args.type as string | undefined,
          limit: (args.limit as number) ?? 20,
        });

        if (response.entries.length === 0) {
          return `No stale entries found (all verified within ${days} days)`;
        }

        const lines = [
          `## Stale Entries (not verified in ${days} days)`,
          "",
          `Found ${response.total} entries needing verification:`,
          "",
        ];

        for (const entry of response.entries) {
          const daysSince = entry.daysSinceVerified !== null
            ? `${entry.daysSinceVerified} days ago`
            : "never";
          lines.push(`- **${entry.title}**`);
          lines.push(`  \`${entry.path}\` | Last verified: ${daysSince}`);
        }

        lines.push("");
        lines.push("*Use `brain_verify` to mark entries as still accurate.*");

        return lines.join("\n");
      }

      case "brain_verify": {
        await apiRequest<{ message: string; path: string }>(
          "POST",
          `/entries/${args.path}/verify`
        );

        return `Verified: ${args.path}

Entry marked as still accurate. It will not appear in stale entry lists for 30 days.`;
      }

      case "brain_delete": {
        if (!args.confirm) {
          return "Please set `confirm: true` to delete the entry";
        }

        await apiRequest<{ message: string; path: string }>(
          "DELETE",
          `/entries/${args.path}`,
          undefined,
          { confirm: "true" }
        );

        return `Deleted: ${args.path}`;
      }

      case "brain_link": {
        if (!args.path && !args.title) {
          return "Please provide either a path, ID, or title to generate a link";
        }

        const response = await apiRequest<{
          link: string;
          id: string;
          path: string;
          title: string;
        }>("POST", "/link", {
          title: args.title,
          path: args.path,
          withTitle: args.withTitle,
        });

        return `Link: ${response.link}\nID: ${response.id}\nPath: ${response.path}\nTitle: ${response.title}`;
      }

      case "brain_section": {
        if (!args.planId || !args.sectionTitle) {
          return "Please provide both planId and sectionTitle";
        }

        const encodedTitle = encodeURIComponent(args.sectionTitle as string);
        const response = await apiRequest<{
          title: string;
          content: string;
          level: number;
          line: number;
        }>(
          "GET",
          `/entries/${args.planId}/sections/${encodedTitle}`,
          undefined,
          {
            includeSubsections: args.includeSubsections !== false ? "true" : "false",
          }
        );

        const lines = [
          `## Section: ${response.title}`,
          "",
          `**Plan:** ${args.planId}`,
          `**Line:** ${response.line}`,
          "",
          "---",
          "",
          response.content,
        ];

        return lines.join("\n");
      }

      case "brain_plan_sections": {
        if (!args.path && !args.title) {
          return "Please provide either a path or title";
        }

        // If title provided, search first
        let entryPath = args.path as string | undefined;
        if (!entryPath && args.title) {
          const searchResult = await apiRequest<{
            results: Array<{ path: string; title: string }>;
          }>("POST", "/search", {
            query: args.title,
            limit: 5,
          });

          const exactMatch = searchResult.results.find(r => r.title === args.title);
          if (exactMatch) {
            entryPath = exactMatch.path;
          } else if (searchResult.results.length > 0) {
            const suggestions = searchResult.results.slice(0, 5).map(r => r.title).join(", ");
            return `No exact match for title: "${args.title}"\n\nDid you mean: ${suggestions}`;
          } else {
            return `No entry found matching title: "${args.title}"`;
          }
        }

        const response = await apiRequest<{
          sections: Array<{
            title: string;
            level: number;
            line: number;
          }>;
          total: number;
        }>("GET", `/entries/${entryPath}/sections`);

        // Get entry details for title
        const entry = await apiRequest<{
          title: string;
          type: string;
        }>("GET", `/entries/${entryPath}`);

        const lines = [
          `## Sections in: ${entry.title}`,
          "",
          `**Path:** ${entryPath}`,
          `**Type:** ${entry.type}`,
          `**Total sections:** ${response.total}`,
          "",
        ];

        for (const section of response.sections) {
          const indent = "  ".repeat(section.level - 1);
          lines.push(`${indent}- ${section.title} (line ${section.line})`);
        }

        return lines.join("\n");
      }

      default:
        return `Unknown tool: ${name}`;
    }
  } catch (error) {
    return `Error: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// ============================================================================
// MCP Server
// ============================================================================

function sendResponse(response: MCPResponse | MCPNotification): void {
  const json = JSON.stringify(response);
  process.stdout.write(`Content-Length: ${Buffer.byteLength(json)}\r\n\r\n${json}`);
}

async function handleRequest(request: MCPRequest): Promise<void> {
  let result: unknown;

  switch (request.method) {
    case "initialize":
      result = {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {},
        },
        serverInfo: {
          name: "brain-mcp",
          version: "1.0.0",
        },
      };
      break;

    case "tools/list":
      result = { tools };
      break;

    case "tools/call": {
      const params = request.params as { name: string; arguments?: Record<string, unknown> };
      const content = await handleToolCall(params.name, params.arguments || {});
      result = {
        content: [{ type: "text", text: content }],
      };
      break;
    }

    default:
      sendResponse({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32601,
          message: `Method not found: ${request.method}`,
        },
      });
      return;
  }

  sendResponse({
    jsonrpc: "2.0",
    id: request.id,
    result,
  });
}

// ============================================================================
// Main
// ============================================================================

async function main(): Promise<void> {
  let buffer = "";

  process.stdin.setEncoding("utf-8");
  process.stdin.on("data", async (chunk: string) => {
    buffer += chunk;

    while (true) {
      const headerEnd = buffer.indexOf("\r\n\r\n");
      if (headerEnd === -1) break;

      const header = buffer.slice(0, headerEnd);
      const contentLengthMatch = header.match(/Content-Length: (\d+)/i);
      if (!contentLengthMatch) {
        buffer = buffer.slice(headerEnd + 4);
        continue;
      }

      const contentLength = parseInt(contentLengthMatch[1], 10);
      const contentStart = headerEnd + 4;
      const contentEnd = contentStart + contentLength;

      if (buffer.length < contentEnd) break;

      const content = buffer.slice(contentStart, contentEnd);
      buffer = buffer.slice(contentEnd);

      try {
        const request = JSON.parse(content) as MCPRequest;
        await handleRequest(request);
      } catch (error) {
        console.error("Parse error:", error);
      }
    }
  });

  process.stdin.on("end", () => {
    process.exit(0);
  });
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
