---
name: do-work-queue
description: Use when processing queued requests - triages complexity, executes with appropriate depth, commits atomically
---

# Do-Work-Queue Skill

Process a task from the queue with complexity triage and dependency awareness. Right-size the process to avoid overhead.

**Announce at start:** "I'm using the do-work-queue skill to process this task."

## Overview

This skill covers:
1. **Triage System** - Route A/B/C for complexity
2. **Task Workflow** - How to process the assigned task
3. **TDD-Dev Dispatch** - When and how to delegate implementation

## Checklist

- [ ] Step 1: Read task with `brain_recall(path: "<task-path>")`
- [ ] Step 2: Mark as in_progress with `brain_update(path: "...", status: "in_progress")`
- [ ] Step 3: Triage complexity (Route A/B/C)
- [ ] Step 4: Append triage decision with `brain_update(path: "...", append: "## Triage\n...")`
- [ ] Step 5: (Route C only) Dispatch explore agent for planning context
- [ ] Step 6: (Routes B, C) Dispatch explore agent, append results
- [ ] Step 7: (Route A) Implement directly OR (Routes B, C) Dispatch `tdd-dev` agent
- [ ] Step 8: Run tests, append results
- [ ] Step 9: Complete task with `brain_update(path: "...", status: "completed", append: "## Summary\n...")`
- [ ] Step 10: Create atomic git commit

---

## Part 1: Complexity Triage

### Route A: Direct Implementation (Simple)

**When:** Task is simple, clear, specific. **Implement directly without exploration or tdd-dev.**

| Indicator | Example |
|-----------|---------|
| Names specific files | "Fix bug in auth.ts line 42" |
| Config/value change | "Update timeout to 60s" |
| Bug with clear steps | "Crash when clicking empty form" |
| Copy/text change | "Update footer copyright" |
| Under 50 words | Short, focused request |

### Route B: Explore then TDD-Dev (Medium)

**When:** Clear goal, unknown location. **Run exploration, then dispatch to tdd-dev.**

| Indicator | Example |
|-----------|---------|
| Pattern matching | "Like we have on the login page" |
| Unknown location | "Add validation to the form" |
| Following conventions | "Create endpoint like existing ones" |

### Route C: Full Pipeline (Complex)

**When:** Complex, architectural, ambiguous. **Run planning, exploration, then dispatch to tdd-dev.**

| Indicator | Example |
|-----------|---------|
| New feature | "Add OAuth authentication" |
| Architectural | "Refactor to use Zustand" |
| Ambiguous scope | "Improve performance" |
| 100+ words | Detailed requirements |
| Multiple components | Touches many files |

### Decision Tree

```
Read task → Names files + clear changes? → Yes → Route A
                    ↓ No
         Bug fix with clear steps? → Yes → Route A
                    ↓ No
         Simple config/copy change? → Yes → Route A
                    ↓ No
         Clear goal, unknown where? → Yes → Route B
                    ↓ No
         Ambiguous or architectural? → Yes → Route C
                    ↓ No
         Default → Route B
```

**When uncertain, prefer Route B.** TDD-Dev can request more context if needed.

### Quick Reference

| Route | Explore | Plan | TDD-Dev | When |
|-------|---------|------|---------|------|
| A | Skip | Skip | No | Simple, specific |
| B | Yes | Skip | Yes | Clear goal, unknown where |
| C | Yes | Yes | Yes | Complex, architectural |

---

## Part 2: Task Workflow

### Step 1: Read Task

```
brain_recall(path: "<task-path-from-prompt>")
```

### Step 2: Claim Task

```
brain_update(path: "<task-path>", status: "in_progress")
```

### Step 3: Triage

Read task content, apply decision tree. Append triage:

```
brain_update(
  path: "<task-path>",
  append: "## Triage\n\n**Route: B** - Medium\n\n**Reasoning:** Clear feature but need to find existing patterns."
)
```

### Step 4: Planning (Route C only)

Use Task tool to spawn explore agent for architectural context:

```
Task(
  subagent_type: "explore",
  description: "Plan <task-title>",
  prompt: "Analyze the codebase to create an implementation plan for: <task-summary>. 
           Identify affected components, dependencies, and suggested phases."
)
```

Append plan results:

```
brain_update(
  path: "<task-path>",
  append: "## Plan\n\n<plan-from-explore-agent>\n\n*Generated by explore agent*"
)
```

### Step 5: Exploration (Routes B, C)

Use Task tool to spawn explore agent:

```
Task(
  subagent_type: "explore",
  description: "Explore for <task-title>",
  prompt: "Find relevant code patterns, existing implementations, and conventions for: <task-summary>"
)
```

Append results:

```
brain_update(
  path: "<task-path>",
  append: "## Exploration\n\n<findings>\n\n*Generated by explore agent*"
)
```

### Step 6: Implementation

**Route A (Simple):** Implement the changes directly. Skip to Step 7.

**Routes B & C:** Dispatch to `tdd-dev` agent with accumulated context.

#### Determining Phased Work (Route C only)

A task requires phased implementation if ANY of:
- Multiple components/modules are touched
- Plan has 3+ distinct sections or steps
- Estimated to modify 4+ files

#### TDD-Dev Dispatch Template

```
Task(
  subagent_type: "tdd-dev",
  description: "Implement <task-title>",
  prompt: """
## Task
<full task content from brain_recall>

## Triage
**Route:** <B or C>
**Reasoning:** <triage reasoning>

## Exploration Results
<exploration findings appended to task>

## Plan (Route C only)
<plan if Route C, omit section for Route B>

## Instructions
Implement this task following TDD discipline (red-green-verify cycle).

<If phased work needed>
This is a large task. Work in phases:
1. Complete Phase 1, verify tests pass
2. Complete Phase 2, verify tests pass
3. Continue until all phases complete

Return a summary of changes after each phase.
</If phased>

<If not phased>
Return a summary of all changes made.
</If not phased>
"""
)
```

After `tdd-dev` returns, append implementation summary:

```
brain_update(
  path: "<task-path>",
  append: "## Implementation\n\n<summary-from-tdd-dev>\n\n*Implemented by tdd-dev agent*"
)
```

### Step 7: Testing

Run relevant tests. Append results:

```
brain_update(
  path: "<task-path>",
  append: "## Testing\n\n**Tests run:** <command>\n**Result:** <pass/fail details>\n\n*Verified*"
)
```

### Step 8: Complete

```
brain_update(
  path: "<task-path>",
  status: "completed",
  append: "## Summary\n\n- <change 1>\n- <change 2>\n\n*Completed*"
)
```

### Step 9: Commit

Single atomic commit per task:

```bash
git add -A
git commit -m "[Task] <title> (Route <A/B/C>)

<implementation summary>"
```

---

## Part 3: Error Handling

### Implementation Fails

1. Mark task as blocked: `brain_update(path: "...", status: "blocked", note: "...")`
2. Report failure details

### Tests Fail

1. Attempt fix (up to 3 times)
2. If still failing, mark as blocked with test failure details
3. Report to user

### Commit Fails

1. Report error (usually pre-commit hook)
2. Do NOT use --no-verify
3. Leave for user to manually fix

---

## Anti-Patterns

**Never:**
- Skip triage (always categorize)
- Implement Routes B/C without dispatching to `tdd-dev`
- Skip the audit trail (triage, exploration, summary)
- Batch multiple tasks in one commit
- Use `--no-verify` on commits

**If blocked:**
- Mark task as blocked with `brain_update`
- Don't try to force through
- Report to user
