---
name: do-work
description: Use when processing queued requests - triages complexity, executes with appropriate depth, commits atomically
---

# Do-Work Skill

Process task queues with complexity triage and dependency awareness. Right-size the process to avoid overhead.

**Announce at start:** "I'm using the do-work skill to process tasks."

## Overview

This skill covers:
1. **Triage System** - Route A/B/C for complexity
2. **Per-Task Workflow** - How to process individual tasks
3. **Script Commands** - Reference for the do-work bash script
4. **Brain Tools** - Queue management operations

The `do-work` bash script (at `~/dot/scripts/do-work`) handles automated execution, dependency resolution, and parallel processing. This skill defines how each task is processed when spawned by the script.

## Checklist

- [ ] Step 1: Find pending tasks with `brain_list(type: "task", status: "pending", sortBy: "priority")`
- [ ] Step 2: Pick highest priority task (high > medium > low)
- [ ] Step 3: Claim task with `brain_update(path: "...", status: "in_progress")`
- [ ] Step 4: Triage complexity (Route A/B/C)
- [ ] Step 5: Append triage decision with `brain_update(path: "...", append: "## Triage\n...")`
- [ ] Step 6: (Route C only) Dispatch plan subagent, append results
- [ ] Step 7: (Routes B,C) Dispatch explore subagent, append results
- [ ] Step 8: Implement the task
- [ ] Step 9: Run tests, append results
- [ ] Step 10: Complete task with `brain_update(path: "...", status: "completed", append: "## Summary\n...")`
- [ ] Step 11: Create atomic git commit
- [ ] Step 12: Loop to next task or report completion

---

## Part 1: Complexity Triage

### Route A: Direct to Build (Simple)

**When:** Task is simple, clear, specific. **Skip planning and exploration entirely.**

| Indicator | Example |
|-----------|---------|
| Names specific files | "Fix bug in auth.ts line 42" |
| Config/value change | "Update timeout to 60s" |
| Bug with clear steps | "Crash when clicking empty form" |
| Copy/text change | "Update footer copyright" |
| Under 50 words | Short, focused request |

### Route B: Explore then Build (Medium)

**When:** Clear goal, unknown location. **Skip planning, run exploration first.**

| Indicator | Example |
|-----------|---------|
| Pattern matching | "Like we have on the login page" |
| Unknown location | "Add validation to the form" |
| Following conventions | "Create endpoint like existing ones" |

### Route C: Full Pipeline (Complex)

**When:** Complex, architectural, ambiguous. **Run planning, then exploration, then build.**

| Indicator | Example |
|-----------|---------|
| New feature | "Add OAuth authentication" |
| Architectural | "Refactor to use Zustand" |
| Ambiguous scope | "Improve performance" |
| 100+ words | Detailed requirements |
| Multiple components | Touches many files |

### Decision Tree

```
Read task → Names files + clear changes? → Yes → Route A
                    ↓ No
         Bug fix with clear steps? → Yes → Route A
                    ↓ No
         Simple config/copy change? → Yes → Route A
                    ↓ No
         Clear goal, unknown where? → Yes → Route B
                    ↓ No
         Ambiguous or architectural? → Yes → Route C
                    ↓ No
         Default → Route B
```

**When uncertain, prefer Route B.** Builder can request planning if needed.

### Quick Reference

| Route | Plan | Explore | Build | When |
|-------|------|---------|-------|------|
| A | Skip | Skip | Yes | Simple, specific |
| B | Skip | Yes | Yes | Clear goal, unknown where |
| C | Yes | Yes | Yes | Complex, architectural |

---

## Part 2: Per-Task Workflow

### Step 1: Find Next Task

```
brain_list(type: "task", status: "pending", sortBy: "priority")
```

Pick the first one (highest priority, then oldest within same priority).

### Step 2: Claim Task

```
brain_update(path: "<task-path>", status: "in_progress")
```

### Step 3: Triage

Read task content, apply decision tree. Append triage:

```
brain_update(
  path: "<task-path>",
  append: "## Triage\n\n**Route: B** - Medium\n\n**Reasoning:** Clear feature but need to find existing patterns."
)
```

### Step 4: Planning (Route C only)

Use Task tool to spawn Plan agent. Append results:

```
brain_update(
  path: "<task-path>",
  append: "## Plan\n\n1. Create theme context\n2. Add hook\n3. Update components\n\n*Generated by Plan agent*"
)
```

### Step 5: Exploration (Routes B, C)

Use Task tool to spawn Explore agent. Append results:

```
brain_update(
  path: "<task-path>",
  append: "## Exploration\n\n- Found similar at src/components/Button.tsx\n- Uses pattern X\n\n*Generated by Explore agent*"
)
```

### Step 6: Implementation (All routes)

Implement the changes directly or via Task tool.

### Step 7: Testing

Run relevant tests. Append results:

```
brain_update(
  path: "<task-path>",
  append: "## Testing\n\n**Tests run:** npm test\n**Result:** All 12 tests passing\n\n*Verified*"
)
```

### Step 8: Complete

```
brain_update(
  path: "<task-path>",
  status: "completed",
  append: "## Implementation Summary\n\n- Created X\n- Modified Y\n\n*Completed*"
)
```

### Step 9: Commit

Single atomic commit per task:

```bash
git add -A
git commit -m "[Task] <title> (Route <A/B/C>)

<implementation summary>"
```

### Step 10: Loop

Check for more pending tasks. If found, continue. If empty, report summary.

---

## Part 3: do-work Script Commands

All dependency resolution AND execution is handled by the `do-work` script. **Do not reimplement dependency logic - use the script.**

### Monitor Commands (Automated Execution)

```bash
# Start the monitor (processes tasks automatically)
do-work start <project> [options]

Options:
  --foreground, -f  Run in foreground (see output directly)
  --tui             Use TUI mode (visible OpenCode in tmux)
  --dry-run         Don't spawn OpenCode, just log what would happen
  --poll-interval N Seconds between polls (default: 30)
  --workdir, -w     Working directory for OpenCode
  --model, -m       Model to use (default: claude-sonnet)
  --max-parallel N  Max concurrent tasks (default: 3)

# Stop the monitor
do-work stop [project]

# Check status
do-work status [project]

# View logs
do-work logs [-f]
```

### Query Commands

```bash
# Show dependency graph
do-work graph [project]

# List ready tasks (dependencies met)
do-work ready [project]

# List waiting tasks
do-work waiting [project]

# List blocked tasks
do-work blocked [project]

# List all tasks
do-work list [project]
```

Default project is "default". Tasks are accessed via the Brain API.

### Task States

| State | Description |
|-------|-------------|
| **ready** | All dependencies completed, can execute |
| **waiting** | Has pending/in_progress dependencies |
| **blocked** | Has blocked/failed/circular dependencies |
| **circular** | Part of a circular dependency chain |

### How the Monitor Works

1. **Poll for ready tasks** - Queries brain for tasks where all dependencies are completed
2. **Pick highest priority** - Selects the first ready task (sorted by priority)
3. **Spawn OpenCode** - Starts OpenCode with a prompt to process the task
4. **Wait for completion** - Monitors task status via Brain API
5. **Re-evaluate dependencies** - After task completes, other tasks may become ready
6. **Repeat** - Continue until no tasks remain

---

## Part 4: Brain Tools Reference

| Action | Tool Call |
|--------|-----------|
| List pending (priority order) | `brain_list(type: "task", status: "pending", sortBy: "priority")` |
| Get task details | `brain_recall(path: "...")` |
| Claim task | `brain_update(path: "...", status: "in_progress")` |
| Append notes | `brain_update(path: "...", append: "## Section\n...")` |
| Complete task | `brain_update(path: "...", status: "completed")` |
| Mark blocked | `brain_update(path: "...", status: "blocked", note: "reason")` |

### Creating Tasks with Dependencies

```
brain_save(
  type: "task",
  title: "Task title",
  content: "Task description and instructions...",
  status: "pending",
  priority: "high",           // high | medium | low
  depends_on: ["other-task-id", "Other Task Title"],  // By ID or title
  project: "my-project",      // Project ID for grouping
  tags: ["task", "feature-x"]
)
```

The `depends_on` field accepts task IDs (8-char alphanumeric) or task titles. Dependencies are resolved automatically by the do-work script.

---

## Part 5: Priority System

Tasks are processed in priority order: high > medium > low

| Priority | When to Use |
|----------|-------------|
| high | Urgent, blocking, critical bugs, P0/P1 |
| medium | Normal work, default priority |
| low | Nice-to-have, cleanup, someday tasks |

Within the same priority, older tasks are processed first (FIFO).

---

## Part 6: Error Handling

### Implementation Fails

1. Mark task as blocked: `brain_update(path: "...", status: "blocked", note: "...")`
2. Continue to next task
3. Report failure to user

### Tests Fail

1. Attempt fix (up to 3 times)
2. If still failing, mark as blocked
3. Include test failure details in note
4. Continue to next task

### Commit Fails

1. Report error (usually pre-commit hook)
2. Do NOT use --no-verify
3. Continue to next task
4. User can manually fix

### Circular Dependencies

When detected by `do-work graph`:
```
Circular Dependencies (ERROR):
  Task A (abc123)
     └─ depends on: Task B (circular)
  Task B (def456)
     └─ depends on: Task A (circular)
```

**Resolution:** Use `brain_update` to remove the circular dependency from one task.

### Interrupted Tasks

On restart, the monitor checks for tasks with status `in_progress` that have no active process:
```
[WARN] Found 1 interrupted task(s), will resume before processing new tasks
```

After 3 resume attempts, tasks are marked as blocked.

---

## Anti-Patterns

**Never:**
- Skip triage (always categorize)
- Implement without reading task via `brain_recall`
- Batch multiple tasks in one commit
- Skip the audit trail (triage, exploration, summary)
- Reimplement dependency resolution logic (use the script)
- Process waiting tasks (dependencies not met)
- Ignore circular dependencies (they must be broken)

**If blocked:**
- Mark task as blocked with `brain_update`
- Don't try to force through
- Let user decide next steps

---

## Example Session

### Manual Processing

```bash
$ /work next

Processing: "Fix login crash" (high)

## Triage
Route A - Simple
Reasoning: Bug fix with clear location mentioned

## Implementation
Fixed null check in src/auth.ts:42

## Testing
npm test - 5/5 passing

## Complete
Committed: abc1234 "[Task] Fix login crash (Route A)"
```

### Automated Processing

```bash
$ /do start myproject

Starting do-work monitor...
  Project: myproject
  Mode: TUI

[INFO] Found ready task: Setup database schema (priority: high)
[INFO] Spawning OpenCode to process: Setup database schema
...
[INFO] Task completed: Setup database schema
[INFO] Dependency resolution: 1 task(s) now ready to execute
[INFO] Found ready task: Implement user model (priority: medium)
...
```
