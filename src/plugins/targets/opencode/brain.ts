/**
 * Brain API Client Plugin for OpenCode
 *
 * A thin API client that calls the Brain API instead of using direct zk CLI
 * and SQLite access. This is a drop-in replacement for the original brain.ts
 * plugin with identical tool interfaces.
 *
 * Configuration:
 * - BRAIN_API_URL: Base URL for the Brain API (default: http://localhost:3333)
 *
 * ============================================================================
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * ============================================================================
 * This file was generated by: brain install opencode
 * To update: brain install opencode --force
 * To check status: brain plugin-status
 * Source: https://github.com/huynle/brain
 * Generated: {{GENERATED_DATE}}
 */

import type { Plugin } from "@opencode-ai/plugin";
import { tool } from "@opencode-ai/plugin";
import { execSync } from "child_process";
import { homedir } from "os";

// ============================================================================
// Types
// ============================================================================

type BrainEntryType =
  | "summary"
  | "report"
  | "walkthrough"
  | "plan"
  | "pattern"
  | "learning"
  | "idea"
  | "scratch"
  | "decision"
  | "exploration"
  | "execution"
  | "task";

type BrainEntryStatus =
  | "draft"
  | "pending"
  | "active"
  | "in_progress"
  | "blocked"
  | "completed"
  | "validated"
  | "superseded"
  | "archived";

type TaskPriority = "high" | "medium" | "low";

// ============================================================================
// Constants
// ============================================================================

const BRAIN_API_URL = process.env.BRAIN_API_URL || "http://localhost:3333";

// ============================================================================
// Health Check & Connection State
// ============================================================================

interface BrainConnectionState {
  available: boolean;
  lastCheck: number;
  lastError?: string;
  version?: string;
}

// Connection state - checked on first tool use and cached
let connectionState: BrainConnectionState = {
  available: false,
  lastCheck: 0,
};

const HEALTH_CHECK_INTERVAL_MS = 30_000; // Re-check every 30 seconds when healthy
const HEALTH_CHECK_RETRY_MS = 5_000; // Re-check every 5 seconds when unhealthy (faster reconnect)

async function checkBrainHealth(): Promise<BrainConnectionState> {
  const now = Date.now();
  
  // Use shorter retry interval when unhealthy for faster reconnect
  const cacheInterval = connectionState.available 
    ? HEALTH_CHECK_INTERVAL_MS 
    : HEALTH_CHECK_RETRY_MS;
  
  // Return cached state if checked recently
  if (now - connectionState.lastCheck < cacheInterval) {
    return connectionState;
  }

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
    
    const response = await fetch(`${BRAIN_API_URL}/api/v1/health`, {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    if (response.ok) {
      const data = await response.json();
      connectionState = {
        available: true,
        lastCheck: now,
        version: data.version,
      };
    } else {
      connectionState = {
        available: false,
        lastCheck: now,
        lastError: `Server returned ${response.status}: ${response.statusText}`,
      };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionRefused = errorMessage.includes("ECONNREFUSED") || 
                                 errorMessage.includes("fetch failed") ||
                                 errorMessage.includes("aborted");
    
    connectionState = {
      available: false,
      lastCheck: now,
      lastError: isConnectionRefused 
        ? `Cannot connect to Brain API at ${BRAIN_API_URL}. Is the server running? Start it with: brain start`
        : `Health check failed: ${errorMessage}`,
    };
  }

  return connectionState;
}

function formatUnavailableMessage(state: BrainConnectionState): string {
  return `**BRAIN API UNAVAILABLE**

The Brain API server is not reachable at ${BRAIN_API_URL}.

**Error:** ${state.lastError || "Unknown error"}

**What this means:**
- Brain tools (save, recall, search, etc.) will not work
- Your knowledge and notes are not accessible right now

**To fix this:**
1. Start the Brain API server: \`brain start\`
2. Or check if it's running: \`brain status\`
3. Or check the logs: \`brain logs\`

**Alternative:** If you don't need brain functionality for this task, you can proceed without it.
The brain tools will automatically reconnect when the server becomes available.`;
}

// ============================================================================
// Execution Context
// ============================================================================

interface ExecutionContext {
  projectId: string; // Human-readable, $HOME-relative
  workdir: string; // $HOME-relative path to main worktree
  worktree?: string; // Specific worktree path if in a worktree
  gitRemote?: string; // Git remote URL
  gitBranch?: string; // Current branch
}

function getExecutionContext(directory: string): ExecutionContext {
  const home = homedir();

  // Get main worktree path (resolves worktrees to their main repo)
  let mainWorktreePath = directory;
  let currentWorktreePath: string | undefined;
  let gitRemote: string | undefined;
  let gitBranch: string | undefined;

  try {
    // Check if we're in a worktree and get the main worktree
    const worktreeList = execSync("git worktree list --porcelain", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    const lines = worktreeList.split("\n");
    const firstWorktreeLine = lines.find((l) => l.startsWith("worktree "));
    if (firstWorktreeLine) {
      mainWorktreePath = firstWorktreeLine.replace("worktree ", "");
    }

    // If current directory is different from main, we're in a worktree
    if (directory !== mainWorktreePath) {
      currentWorktreePath = directory;
    }

    // Get git remote
    gitRemote = execSync("git remote get-url origin", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    // Get current branch
    gitBranch = execSync("git branch --show-current", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();
  } catch {
    // Not a git repo or git not available
  }

  // Make paths relative to $HOME
  const makeHomeRelative = (path: string): string => {
    if (path.startsWith(home)) {
      return path.slice(home.length + 1); // +1 for the slash
    }
    return path;
  };

  const projectId = makeHomeRelative(mainWorktreePath);
  const workdir = makeHomeRelative(mainWorktreePath);
  const worktree = currentWorktreePath
    ? makeHomeRelative(currentWorktreePath)
    : undefined;

  return {
    projectId,
    workdir,
    worktree,
    gitRemote,
    gitBranch,
  };
}

const ENTRY_TYPES: BrainEntryType[] = [
  "summary",
  "report",
  "walkthrough",
  "plan",
  "pattern",
  "learning",
  "idea",
  "scratch",
  "decision",
  "exploration",
  "execution",
  "task",
];

const ENTRY_STATUSES: BrainEntryStatus[] = [
  "draft",
  "pending",
  "active",
  "in_progress",
  "blocked",
  "completed",
  "validated",
  "superseded",
  "archived",
];

// ============================================================================
// API Client
// ============================================================================

interface ApiError {
  error: string;
  message: string;
  details?: unknown;
}

class BrainUnavailableError extends Error {
  constructor(state: BrainConnectionState) {
    super(formatUnavailableMessage(state));
    this.name = "BrainUnavailableError";
  }
}

async function apiRequest<T>(
  method: string,
  path: string,
  body?: unknown,
  queryParams?: Record<string, string | number | boolean | undefined>
): Promise<T> {
  // Check health before making request
  const health = await checkBrainHealth();
  if (!health.available) {
    throw new BrainUnavailableError(health);
  }

  let url = `${BRAIN_API_URL}/api/v1${path}`;

  // Add query parameters
  if (queryParams) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(queryParams)) {
      if (value !== undefined) {
        params.append(key, String(value));
      }
    }
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }
  }

  const options: RequestInit = {
    method,
    headers: {
      "Content-Type": "application/json",
    },
  };

  if (body && (method === "POST" || method === "PATCH" || method === "PUT")) {
    options.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url, options);

    if (!response.ok) {
      let errorData: ApiError;
      try {
        errorData = await response.json();
      } catch {
        errorData = {
          error: "API Error",
          message: `HTTP ${response.status}: ${response.statusText}`,
        };
      }
      throw new Error(errorData.message || `API error: ${response.status}`);
    }

    return response.json();
  } catch (error) {
    // If fetch itself fails (connection error), mark as unavailable and throw helpful message
    if (error instanceof BrainUnavailableError) {
      throw error;
    }
    
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionError = errorMessage.includes("ECONNREFUSED") || 
                              errorMessage.includes("fetch failed") ||
                              errorMessage.includes("network");
    
    if (isConnectionError) {
      // Mark as unavailable for future requests
      connectionState = {
        available: false,
        lastCheck: Date.now(),
        lastError: `Connection lost: ${errorMessage}`,
      };
      throw new BrainUnavailableError(connectionState);
    }
    
    throw error;
  }
}

// ============================================================================
// Plugin
// ============================================================================

export const BrainPlugin: Plugin = async ({ project, directory }) => {
  const context = getExecutionContext(directory);
  const projectId = project?.id || context.projectId || "unknown";

  return {
    tool: {
      // ========================================
      // brain_save
      // ========================================
      brain_save: tool({
        description: `Save content to the brain for future reference. Use this to persist:
- summaries: Session summaries, key decisions made
- reports: Analysis reports, code reviews, investigations
- walkthroughs: Code explanations, architecture overviews
- plans: Implementation plans, designs, roadmaps
- patterns: Reusable patterns discovered (use global:true for cross-project)
- learnings: General learnings, best practices (use global:true for cross-project)
- ideas: Ideas for future exploration
- scratch: Temporary working notes
- decision: Architectural decisions, ADRs
- exploration: Investigation notes, research findings`,
        args: {
          type: tool.schema
            .enum(ENTRY_TYPES)
            .describe("Type of content being saved"),
          title: tool.schema
            .string()
            .describe("Short descriptive title for the entry"),
          content: tool.schema
            .string()
            .describe("The content to save (markdown supported)"),
          tags: tool.schema
            .array(tool.schema.string())
            .optional()
            .describe("Tags for categorization and search"),
          status: tool.schema
            .enum(ENTRY_STATUSES)
            .optional()
            .describe(
              "Initial status (default: 'active'). Use 'draft' for work-in-progress."
            ),
          priority: tool.schema
            .enum(["high", "medium", "low"])
            .optional()
            .describe(
              "Priority level for tasks. High = urgent/blocking, Medium = normal, Low = nice-to-have."
            ),
          depends_on: tool.schema
            .array(tool.schema.string())
            .optional()
            .describe(
              "Task dependencies - list of task IDs or titles that must be completed before this task."
            ),
          global: tool.schema
            .boolean()
            .optional()
            .describe(
              "Save to global brain (cross-project). Recommended for patterns and learnings."
            ),
          project: tool.schema
            .string()
            .optional()
            .describe(
              "Explicit project ID/name for task organization. If not provided, uses current git repo hash or 'global'."
            ),
          relatedEntries: tool.schema
            .array(tool.schema.string())
            .optional()
            .describe(
              "Titles or paths of related brain entries to link to. Auto-generates markdown links."
            ),
          user_original_request: tool.schema
            .string()
            .optional()
            .describe(
              "Verbatim user request for this task. HIGHLY RECOMMENDED for tasks - enables validation during task completion by comparing implementation against original intent. Supports multiline content, code blocks, and special characters. When creating multiple tasks from one user request, include this in EACH task."
            ),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              id: string;
              path: string;
              title: string;
              type: string;
              status: string;
              link: string;
            }>("POST", "/entries", {
              type: args.type,
              title: args.title,
              content: args.content,
              tags: args.tags,
              status: args.status,
              priority: args.priority,
              depends_on: args.depends_on,
              global: args.global,
              project: args.project || projectId,
              relatedEntries: args.relatedEntries,
              // Execution context for tasks
              workdir: args.type === "task" ? context.workdir : undefined,
              worktree: args.type === "task" ? context.worktree : undefined,
              git_remote: args.type === "task" ? context.gitRemote : undefined,
              git_branch: args.type === "task" ? context.gitBranch : undefined,
              // User intent for validation
              user_original_request:
                args.type === "task" ? args.user_original_request : undefined,
            });

            const location = args.global ? "global brain" : "project brain";

            return `Saved to ${location}

**Path:** \`${response.path}\`
**ID:** \`${response.id}\`
**Link:** \`${response.link}\`
**Title:** ${response.title}
**Type:** ${response.type}
**Status:** ${response.status}
**Tags:** ${args.tags?.length ? args.tags.join(", ") : "none"}

Use \`brain_recall\` with the path, ID, or title to retrieve it later.
Use the link \`${response.link}\` to reference this entry from other notes.
Use \`brain_update\` to change status (e.g., mark as completed).
Use \`brain_link\` to generate links to this entry from other notes.`;
          } catch (error) {
            return `Failed to save: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_recall
      // ========================================
      brain_recall: tool({
        description:
          "Retrieve a specific entry from the brain by path, ID, or title. Updates access statistics.",
        args: {
          path: tool.schema
            .string()
            .optional()
            .describe("Path or ID (8-char alphanumeric) to the note"),
          title: tool.schema
            .string()
            .optional()
            .describe("Title to search for (exact match)"),
        },
        async execute(args) {
          if (!args.path && !args.title) {
            return "Please provide a path, ID, or title to recall";
          }

          try {
            // If title provided, search first
            let entryPath = args.path;
            if (!entryPath && args.title) {
              const searchResult = await apiRequest<{
                results: Array<{ path: string; title: string }>;
              }>("POST", "/search", {
                query: args.title,
                limit: 5,
              });

              const exactMatch = searchResult.results.find(
                (r) => r.title === args.title
              );
              if (exactMatch) {
                entryPath = exactMatch.path;
              } else if (searchResult.results.length > 0) {
                const suggestions = searchResult.results
                  .slice(0, 5)
                  .map((r) => `- "${r.title}" (Path: \`${r.path}\`)`)
                  .join("\n");
                return `No exact match for: "${args.title}"\n\n**Did you mean:**\n${suggestions}\n\nUse \`brain_recall\` with the exact path to retrieve a specific entry.`;
              } else {
                return `No entry found matching title: "${args.title}"`;
              }
            }

            const response = await apiRequest<{
              id: string;
              path: string;
              title: string;
              type: string;
              status: string;
              content: string;
              tags: string[];
              access_count?: number;
              backlinks?: Array<{ id: string; title: string; path: string }>;
              user_original_request?: string;
            }>("GET", `/entries/${entryPath}`);

            const backlinkLinks =
              response.backlinks && response.backlinks.length > 0
                ? response.backlinks.map((b) => `[${b.title}](${b.id})`)
                : [];

            return `## ${response.title}

**Path:** \`${response.path}\`
**ID:** \`${response.id}\`
**Link:** \`[${response.title}](${response.id})\`
**Type:** ${response.type}
**Status:** ${response.status}
**Tags:** ${response.tags?.join(", ") || "none"}
**Access Count:** ${response.access_count ?? 1}
${backlinkLinks.length > 0 ? `**Backlinks:** ${backlinkLinks.join(", ")}` : ""}
${response.user_original_request ? `**User Original Request:** ${response.user_original_request}` : ""}

---

${response.content}`;
          } catch (error) {
            const identifier = args.path || args.title;
            return `No entry found${args.path ? ` at path: ${args.path}` : ` matching title: "${args.title}"`}: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_search
      // ========================================
      brain_search: tool({
        description:
          "Search the brain using full-text search. Finds entries matching your query.",
        args: {
          query: tool.schema.string().describe("Search query"),
          type: tool.schema
            .enum(ENTRY_TYPES)
            .optional()
            .describe("Filter by entry type"),
          status: tool.schema
            .enum(ENTRY_STATUSES)
            .optional()
            .describe(
              "Filter by status (e.g., 'active', 'completed', 'in_progress')"
            ),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum results (default: 10)"),
          global: tool.schema
            .boolean()
            .optional()
            .describe("Search only global entries"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              results: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
                status: string;
                snippet: string;
              }>;
              total: number;
            }>("POST", "/search", {
              query: args.query,
              type: args.type,
              status: args.status,
              limit: args.limit ?? 10,
              global: args.global,
            });

            if (response.results.length === 0) {
              return `No entries found matching "${args.query}"`;
            }

            const lines = [
              `## Search Results for "${args.query}"`,
              "",
              `Found ${response.total} entries:`,
              "",
            ];

            for (const result of response.results) {
              lines.push(`### ${result.title}`);
              lines.push(`\`${result.path}\` | ${result.type} | ${result.status}`);
              if (result.snippet) lines.push(`> ${result.snippet}...`);
              lines.push("");
            }

            return lines.join("\n");
          } catch (error) {
            return `Search failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_list
      // ========================================
      brain_list: tool({
        description: `List entries in the brain with optional filtering by type, status, and filename.

Filename filtering supports:
- Exact match: "abc12def" finds entry with that exact ID
- Wildcard patterns: "abc*" (prefix), "*def" (suffix), "abc*def" (contains)`,
        args: {
          type: tool.schema
            .enum(ENTRY_TYPES)
            .optional()
            .describe("Filter by entry type"),
          status: tool.schema
            .enum(ENTRY_STATUSES)
            .optional()
            .describe(
              "Filter by status (e.g., 'active', 'completed', 'in_progress')"
            ),
          filename: tool.schema
            .string()
            .optional()
            .describe(
              "Filter by filename/ID. Supports exact match or wildcard patterns with '*'"
            ),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum entries to return (default: 20)"),
          global: tool.schema
            .boolean()
            .optional()
            .describe("List only global entries"),
          sortBy: tool.schema
            .enum(["created", "modified", "priority"])
            .optional()
            .describe(
              "Sort order: 'created' (default), 'modified', or 'priority' (high first)"
            ),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
                status: string;
                priority?: string;
                access_count?: number;
              }>;
              total: number;
            }>(
              "GET",
              "/entries",
              undefined,
              {
                type: args.type,
                status: args.status,
                filename: args.filename,
                limit: args.limit ?? 20,
                global: args.global,
                sortBy: args.sortBy,
              }
            );

            const filterParts = [
              args.type,
              args.status,
              args.filename ? `filename:${args.filename}` : null,
            ].filter(Boolean);
            const filterDesc = filterParts.join(", ");

            if (response.entries.length === 0) {
              return `No entries found${filterDesc ? ` matching: ${filterDesc}` : ""}`;
            }

            const lines = [
              `## Brain Entries${filterDesc ? ` (${filterDesc})` : ""}`,
              "",
              `Found ${response.total} entries:`,
              "",
            ];

            for (const entry of response.entries) {
              const globalBadge = entry.path.startsWith("global/") ? " [global]" : "";
              const priorityBadge = entry.priority
                ? entry.priority === "high"
                  ? " [HIGH]"
                  : entry.priority === "medium"
                    ? " [MED]"
                    : " [LOW]"
                : "";

              lines.push(`- **${entry.title}**${globalBadge}${priorityBadge}`);
              const priorityInfo = entry.priority ? ` | ${entry.priority}` : "";
              lines.push(
                `  \`${entry.path}\` (ID: \`${entry.id}\`) | ${entry.type} | ${entry.status}${priorityInfo} | ${entry.access_count ?? 0} accesses`
              );
            }

            return lines.join("\n");
          } catch (error) {
            return `List failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_inject
      // ========================================
      brain_inject: tool({
        description:
          "Search the brain and return relevant context. Use this to recall knowledge before starting a task.",
        args: {
          query: tool.schema
            .string()
            .describe("What context are you looking for?"),
          maxEntries: tool.schema
            .number()
            .optional()
            .describe("Maximum entries to include (default: 5)"),
          type: tool.schema
            .enum(ENTRY_TYPES)
            .optional()
            .describe("Filter by entry type"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              context: string;
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
              }>;
            }>("POST", "/inject", {
              query: args.query,
              maxEntries: args.maxEntries ?? 5,
              type: args.type,
            });

            if (!response.context || response.entries.length === 0) {
              return `No relevant brain context found for "${args.query}"`;
            }

            return response.context;
          } catch (error) {
            return `Failed to inject context: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_backlinks
      // ========================================
      brain_backlinks: tool({
        description: "Find entries that link TO a given entry (backlinks).",
        args: {
          path: tool.schema.string().describe("Path to the target note"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
              }>;
              total: number;
            }>("GET", `/entries/${args.path}/backlinks`);

            if (response.entries.length === 0) {
              return `No backlinks found for: ${args.path}`;
            }

            const lines = [
              `## Backlinks to: ${args.path}`,
              "",
              `Found ${response.total} entries linking to this note:`,
              "",
            ];

            for (const entry of response.entries) {
              lines.push(
                `- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`
              );
            }

            return lines.join("\n");
          } catch (error) {
            return `Failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_outlinks
      // ========================================
      brain_outlinks: tool({
        description: "Find entries that a given entry links TO (outlinks).",
        args: {
          path: tool.schema.string().describe("Path to the source note"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
              }>;
              total: number;
            }>("GET", `/entries/${args.path}/outlinks`);

            if (response.entries.length === 0) {
              return `No outlinks found from: ${args.path}`;
            }

            const lines = [
              `## Outlinks from: ${args.path}`,
              "",
              `Found ${response.total} entries linked from this note:`,
              "",
            ];

            for (const entry of response.entries) {
              lines.push(
                `- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`
              );
            }

            return lines.join("\n");
          } catch (error) {
            return `Failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_related
      // ========================================
      brain_related: tool({
        description:
          "Find entries that share linked notes with a given entry.",
        args: {
          path: tool.schema
            .string()
            .describe("Path to the note to find related entries for"),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum results (default: 10)"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
              }>;
              total: number;
            }>("GET", `/entries/${args.path}/related`, undefined, {
              limit: args.limit ?? 10,
            });

            if (response.entries.length === 0) {
              return `No related entries found for: ${args.path}`;
            }

            const lines = [
              `## Related to: ${args.path}`,
              "",
              `Found ${response.total} entries sharing links:`,
              "",
            ];

            for (const entry of response.entries) {
              lines.push(
                `- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`
              );
            }

            return lines.join("\n");
          } catch (error) {
            return `Failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_orphans
      // ========================================
      brain_orphans: tool({
        description:
          "Find entries with no incoming links (orphans). Useful for knowledge graph health.",
        args: {
          type: tool.schema
            .enum(ENTRY_TYPES)
            .optional()
            .describe("Filter by entry type"),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum results (default: 20)"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
              }>;
              total: number;
              message: string;
            }>("GET", "/orphans", undefined, {
              type: args.type,
              limit: args.limit ?? 20,
            });

            if (response.entries.length === 0) {
              return `No orphan entries found${args.type ? ` of type "${args.type}"` : ""}`;
            }

            const lines = [
              `## Orphan Entries${args.type ? ` (${args.type})` : ""}`,
              "",
              `Found ${response.total} entries with no incoming links:`,
              "",
            ];

            for (const entry of response.entries) {
              lines.push(
                `- **${entry.title}** (\`${entry.path}\`) - ${entry.type}`
              );
            }

            lines.push("");
            lines.push(
              "*Consider linking these notes from related entries to improve knowledge graph connectivity.*"
            );

            return lines.join("\n");
          } catch (error) {
            return `Failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_stale
      // ========================================
      brain_stale: tool({
        description:
          "Find entries that may need verification (not verified in N days).",
        args: {
          days: tool.schema
            .number()
            .optional()
            .describe("Days threshold (default: 30)"),
          type: tool.schema
            .enum(ENTRY_TYPES)
            .optional()
            .describe("Filter by entry type"),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum results (default: 20)"),
        },
        async execute(args) {
          const days = args.days ?? 30;

          try {
            const response = await apiRequest<{
              entries: Array<{
                id: string;
                path: string;
                title: string;
                type: string;
                daysSinceVerified: number | null;
              }>;
              total: number;
            }>("GET", "/stale", undefined, {
              days,
              type: args.type,
              limit: args.limit ?? 20,
            });

            if (response.entries.length === 0) {
              return `No stale entries found (all verified within ${days} days)`;
            }

            const lines = [
              `## Stale Entries (not verified in ${days} days)`,
              "",
              `Found ${response.total} entries needing verification:`,
              "",
            ];

            for (const entry of response.entries) {
              const daysSince =
                entry.daysSinceVerified !== null
                  ? `${entry.daysSinceVerified} days ago`
                  : "never";
              lines.push(`- **${entry.title}**`);
              lines.push(
                `  \`${entry.path}\` | Last verified: ${daysSince}`
              );
            }

            lines.push("");
            lines.push(
              "*Use `brain_verify` to mark entries as still accurate.*"
            );

            return lines.join("\n");
          } catch (error) {
            return `Failed: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_verify
      // ========================================
      brain_verify: tool({
        description:
          "Mark an entry as verified (still accurate). Updates the last_verified timestamp.",
        args: {
          path: tool.schema.string().describe("Path to the note to verify"),
        },
        async execute(args) {
          try {
            await apiRequest<{ message: string; path: string }>(
              "POST",
              `/entries/${args.path}/verify`
            );

            return `Verified: ${args.path}

Entry marked as still accurate. It will not appear in stale entry lists for 30 days.`;
          } catch (error) {
            return `Entry not found: ${args.path}`;
          }
        },
      }),

      // ========================================
      // brain_update
      // ========================================
      brain_update: tool({
        description: `Update an existing brain entry's status, title, dependencies, or append content.

Use cases:
- Mark a plan as completed: brain_update(path: "...", status: "completed")
- Mark as in-progress: brain_update(path: "...", status: "in_progress")  
- Block with reason: brain_update(path: "...", status: "blocked", note: "Waiting on API design")
- Append progress notes: brain_update(path: "...", append: "## Progress\\n- Completed auth module")
- Update title: brain_update(path: "...", title: "New Title")
- Update dependencies: brain_update(path: "...", depends_on: ["task-id-1", "task-id-2"])

Statuses: draft, active, in_progress, blocked, completed, validated, superseded, archived`,
        args: {
          path: tool.schema.string().describe("Path to the entry to update"),
          status: tool.schema
            .enum(ENTRY_STATUSES)
            .optional()
            .describe("New status for the entry"),
          title: tool.schema
            .string()
            .optional()
            .describe("New title for the entry"),
          append: tool.schema
            .string()
            .optional()
            .describe("Content to append to the entry body"),
          note: tool.schema
            .string()
            .optional()
            .describe("Short note to add (e.g., reason for status change)"),
          depends_on: tool.schema
            .array(tool.schema.string())
            .optional()
            .describe("Task dependencies - list of task IDs or titles"),
        },
        async execute(args) {
          if (!args.status && !args.title && !args.append && !args.note && !args.depends_on) {
            return `No updates specified. Provide at least one of: status, title, append, note, depends_on`;
          }

          try {
            const response = await apiRequest<{
              path: string;
              title: string;
              status: string;
              changes: string[];
            }>("PATCH", `/entries/${args.path}`, {
              status: args.status,
              title: args.title,
              append: args.append,
              note: args.note,
              depends_on: args.depends_on,
            });

            const changes: string[] = [];
            if (args.status) changes.push(`Status: -> ${args.status}`);
            if (args.title) changes.push(`Title: -> "${args.title}"`);
            if (args.note) changes.push(`Note: "${args.note}"`);
            if (args.append)
              changes.push(`Appended ${args.append.length} characters`);
            if (args.depends_on)
              changes.push(`Dependencies: ${args.depends_on.length} task(s)`);

            return `Updated: ${args.path}

**Changes:**
${changes.map((c) => `- ${c}`).join("\n")}

**Current Status:** ${response.status}
**Title:** ${response.title}

Use \`brain_recall\` to view the full entry.`;
          } catch (error) {
            return `Failed to update: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_stats
      // ========================================
      brain_stats: tool({
        description: "Get statistics about the brain storage.",
        args: {
          global: tool.schema
            .boolean()
            .optional()
            .describe("Show only global entries stats"),
        },
        async execute(args) {
          try {
            const response = await apiRequest<{
              zkAvailable: boolean;
              zkVersion: string | null;
              notebookExists: boolean;
              brainDir: string;
              dbPath: string;
              totalEntries: number;
              globalEntries: number;
              projectEntries: number;
              byType: Record<string, number>;
              orphanCount: number;
              trackedEntries: number;
              staleCount: number;
            }>("GET", "/stats", undefined, {
              global: args.global,
            });

            const lines = [
              "## Brain Statistics",
              "",
              "### System",
              `- **zk CLI:** ${response.zkAvailable ? `v${response.zkVersion}` : "Not available"}`,
              `- **Notebook:** ${response.notebookExists ? `${response.brainDir}` : "Not initialized"}`,
              `- **Database:** ${response.dbPath}`,
              "",
              "### Entries",
              `- **Total:** ${response.totalEntries}`,
              `- **Global:** ${response.globalEntries}`,
              `- **Project:** ${response.projectEntries}`,
              "",
              "### By Type",
            ];

            const sortedTypes = Object.entries(response.byType).sort(
              (a, b) => b[1] - a[1]
            );
            for (const [type, count] of sortedTypes) {
              lines.push(`- ${type}: ${count}`);
            }

            lines.push("");
            lines.push("### Health");
            lines.push(`- **Orphan Notes:** ${response.orphanCount}`);
            lines.push("");
            lines.push("### Access Tracking");
            lines.push(`- **Tracked Entries:** ${response.trackedEntries}`);
            lines.push(`- **Stale (>30 days):** ${response.staleCount}`);

            return lines.join("\n");
          } catch (error) {
            return `Failed to get stats: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_delete
      // ========================================
      brain_delete: tool({
        description:
          "Delete a specific entry from the brain by path. Use with caution.",
        args: {
          path: tool.schema.string().describe("Path to the entry to delete"),
          confirm: tool.schema
            .boolean()
            .describe("Must be true to confirm deletion"),
        },
        async execute(args) {
          if (!args.confirm) {
            return "Please set `confirm: true` to delete the entry";
          }

          try {
            await apiRequest<{ message: string; path: string }>(
              "DELETE",
              `/entries/${args.path}`,
              undefined,
              { confirm: "true" }
            );

            return `Deleted: ${args.path}`;
          } catch (error) {
            return `Entry not found: ${args.path}`;
          }
        },
      }),

      // ========================================
      // brain_link
      // ========================================
      brain_link: tool({
        description:
          "Generate a markdown link to a brain entry. Use this when referencing other brain entries to ensure proper link resolution with mkdnflow.",
        args: {
          title: tool.schema.string().optional().describe("Title to search for"),
          path: tool.schema
            .string()
            .optional()
            .describe("Direct path or ID (8-char alphanumeric) to the entry"),
          withTitle: tool.schema
            .boolean()
            .optional()
            .describe("Include title in link (default: true)"),
        },
        async execute(args) {
          if (!args.path && !args.title) {
            return JSON.stringify({
              error: "Please provide either a path, ID, or title to generate a link",
            });
          }

          try {
            const response = await apiRequest<{
              link: string;
              id: string;
              path: string;
              title: string;
            }>("POST", "/link", {
              title: args.title,
              path: args.path,
              withTitle: args.withTitle,
            });

            return JSON.stringify(response);
          } catch (error) {
            return JSON.stringify({
              error: error instanceof Error ? error.message : String(error),
            });
          }
        },
      }),

      // ========================================
      // brain_section
      // ========================================
      brain_section: tool({
        description: `Retrieve a specific section's FULL CONTENT from a brain plan by section title.

Use this when you need the detailed implementation spec for your assigned task.
Returns the exact section content including all subsections, code examples, and acceptance criteria.

Example: brain_section({ planId: "projects/abc/plan/auth.md", sectionTitle: "JWT Middleware" })

This is more precise than brain_inject (which uses fuzzy search) - it extracts the exact section you need.`,
        args: {
          planId: tool.schema
            .string()
            .describe(
              "Brain plan path (from orchestration context or brain_plan_sections)"
            ),
          sectionTitle: tool.schema
            .string()
            .describe("Section title to retrieve (can be partial match)"),
          includeSubsections: tool.schema
            .boolean()
            .optional()
            .describe("Include nested subsections (default: true)"),
        },
        async execute(args) {
          try {
            const encodedTitle = encodeURIComponent(args.sectionTitle);
            const response = await apiRequest<{
              title: string;
              content: string;
              level: number;
              line: number;
            }>(
              "GET",
              `/entries/${args.planId}/sections/${encodedTitle}`,
              undefined,
              {
                includeSubsections:
                  args.includeSubsections !== false ? "true" : "false",
              }
            );

            return JSON.stringify(
              {
                planId: args.planId,
                sectionTitle: response.title,
                content: response.content,
                lineRange: { start: response.line },
                contentLength: response.content.length,
              },
              null,
              2
            );
          } catch (error) {
            return JSON.stringify(
              {
                error: `Section "${args.sectionTitle}" not found in plan`,
                hint: "Use brain_plan_sections to list available sections",
              },
              null,
              2
            );
          }
        },
      }),

      // ========================================
      // brain_check_connection
      // ========================================
      brain_check_connection: tool({
        description: `Check if the Brain API server is running and accessible.

Use this tool FIRST if you're unsure whether brain tools will work.
Returns connection status, server version, and helpful troubleshooting info if unavailable.

This is useful to:
- Verify the brain is available before starting a task that needs it
- Diagnose why other brain tools are failing
- Get instructions for starting the brain server`,
        args: {},
        async execute() {
          // Force a fresh health check
          connectionState.lastCheck = 0;
          const health = await checkBrainHealth();

          if (health.available) {
            return `**Brain API Status: CONNECTED**

- **Server URL:** ${BRAIN_API_URL}
- **Version:** ${health.version || "unknown"}
- **Status:** Ready to use

All brain tools (save, recall, search, inject, etc.) are available.`;
          } else {
            return `**Brain API Status: UNAVAILABLE**

- **Server URL:** ${BRAIN_API_URL}
- **Error:** ${health.lastError || "Unknown error"}

**To start the Brain API server:**
\`\`\`bash
brain start
\`\`\`

**To check server status:**
\`\`\`bash
brain status
\`\`\`

**To view logs:**
\`\`\`bash
brain logs
\`\`\`

Brain tools will not work until the server is running.
You can proceed with tasks that don't require brain functionality.`;
          }
        },
      }),

      // ========================================
      // brain_tasks
      // ========================================
      brain_tasks: tool({
        description: `List all tasks for current project with dependency status (ready/waiting/blocked), stats, and cycles detected.

Use this to see:
- Which tasks are ready to work on (dependencies met)
- Which tasks are waiting (dependencies incomplete)
- Which tasks are blocked (circular deps or blocked deps)
- Overall task queue stats`,
        args: {
          status: tool.schema
            .enum(ENTRY_STATUSES)
            .optional()
            .describe("Filter by task status (pending, in_progress, completed, etc.)"),
          classification: tool.schema
            .enum(["ready", "waiting", "blocked"])
            .optional()
            .describe("Filter by dependency classification"),
          limit: tool.schema
            .number()
            .optional()
            .describe("Maximum results to return (default: 50)"),
          project: tool.schema
            .string()
            .optional()
            .describe("Override auto-detected project"),
        },
        async execute(args) {
          try {
            const proj = args.project || projectId;
            
            interface TaskWithDeps {
              id: string;
              title: string;
              status: string;
              priority?: string;
              classification: string;
              dependsOn?: Array<{ id: string; title: string; status: string }>;
              blockedBy?: string;
            }
            
            interface TaskListResponse {
              tasks: TaskWithDeps[];
              count: number;
              stats?: {
                ready: number;
                waiting: number;
                blocked: number;
                completed: number;
                total: number;
              };
              cycles?: Array<{ taskId: string; cycle: string[] }>;
            }
            
            const response = await apiRequest<TaskListResponse>(
              "GET",
              `/tasks/${encodeURIComponent(proj)}`
            );

            // Apply filters
            let filteredTasks = response.tasks;
            
            if (args.status) {
              filteredTasks = filteredTasks.filter(t => t.status === args.status);
            }
            
            if (args.classification) {
              filteredTasks = filteredTasks.filter(t => t.classification === args.classification);
            }
            
            const limit = args.limit ?? 50;
            filteredTasks = filteredTasks.slice(0, limit);

            // Group by classification
            const ready = filteredTasks.filter(t => t.classification === "ready");
            const waiting = filteredTasks.filter(t => t.classification === "waiting");
            const blocked = filteredTasks.filter(t => t.classification === "blocked");

            const lines: string[] = [];
            lines.push(`## Tasks for project: ${proj}`);
            lines.push("");

            // Stats summary
            if (response.stats) {
              const s = response.stats;
              lines.push(`**Stats:** ${s.ready} ready | ${s.waiting} waiting | ${s.blocked} blocked | ${s.completed} completed`);
              lines.push("");
            }

            // Ready tasks
            if (ready.length > 0) {
              lines.push("### Ready (can start now)");
              for (const task of ready) {
                const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
                lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
                if (task.dependsOn && task.dependsOn.length > 0) {
                  const deps = task.dependsOn.map(d => `${d.title} (${d.status})`).join(", ");
                  lines.push(`  Dependencies: ${deps}`);
                } else {
                  lines.push("  Dependencies: none");
                }
              }
              lines.push("");
            }

            // Waiting tasks
            if (waiting.length > 0) {
              lines.push("### Waiting (deps incomplete)");
              for (const task of waiting) {
                const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
                lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
                if (task.dependsOn && task.dependsOn.length > 0) {
                  const incomplete = task.dependsOn.filter(d => d.status !== "completed");
                  const deps = incomplete.map(d => `${d.title} (${d.status})`).join(", ");
                  lines.push(`  Waiting on: ${deps}`);
                }
              }
              lines.push("");
            }

            // Blocked tasks
            if (blocked.length > 0) {
              lines.push("### Blocked");
              for (const task of blocked) {
                const priority = task.priority === "high" ? "[HIGH]" : task.priority === "medium" ? "[MED]" : "[LOW]";
                lines.push(`- **${priority} ${task.title}** (\`${task.id}\`) - ${task.status}`);
                lines.push(`  Blocked by: ${task.blockedBy || "circular dependency or blocked deps"}`);
              }
              lines.push("");
            }

            // Cycles warning
            if (response.cycles && response.cycles.length > 0) {
              lines.push("### Circular Dependencies Detected");
              for (const cycle of response.cycles) {
                lines.push(`- Cycle: ${cycle.cycle.join(" -> ")}`);
              }
              lines.push("");
            }

            if (filteredTasks.length === 0) {
              lines.push("*No tasks found matching criteria.*");
            }

            return lines.join("\n");
          } catch (error) {
            return `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`;
          }
        },
      }),

      // ========================================
      // brain_plan_sections
      // ========================================
      brain_plan_sections: tool({
        description:
          "Extract section headers from a plan entry for orchestration mapping.",
        args: {
          path: tool.schema
            .string()
            .optional()
            .describe("Path to the plan entry"),
          title: tool.schema
            .string()
            .optional()
            .describe("Title to search for"),
        },
        async execute(args) {
          if (!args.path && !args.title) {
            return JSON.stringify({ error: "Please provide either a path or title" });
          }

          try {
            // If title provided, search first
            let entryPath = args.path;
            if (!entryPath && args.title) {
              const searchResult = await apiRequest<{
                results: Array<{ path: string; title: string }>;
              }>("POST", "/search", {
                query: args.title,
                limit: 5,
              });

              const exactMatch = searchResult.results.find(
                (r) => r.title === args.title
              );
              if (exactMatch) {
                entryPath = exactMatch.path;
              } else if (searchResult.results.length > 0) {
                const suggestions = searchResult.results
                  .slice(0, 5)
                  .map((r) => r.title);
                return JSON.stringify({
                  error: `No exact match for title: "${args.title}"`,
                  suggestions,
                  hint: "Use brain_plan_sections with the exact path instead",
                });
              } else {
                return JSON.stringify({
                  error: `No entry found matching title: "${args.title}"`,
                });
              }
            }

            const response = await apiRequest<{
              sections: Array<{
                title: string;
                level: number;
                line: number;
              }>;
              total: number;
            }>("GET", `/entries/${entryPath}/sections`);

            // Get entry details for title
            const entry = await apiRequest<{
              title: string;
              type: string;
            }>("GET", `/entries/${entryPath}`);

            return JSON.stringify(
              {
                path: entryPath,
                title: entry.title,
                type: entry.type,
                sections: response.sections,
                sectionTitles: response.sections.map((s) => s.title),
              },
              null,
              2
            );
          } catch (error) {
            return JSON.stringify({
              error: error instanceof Error ? error.message : String(error),
            });
          }
        },
      }),
    },
  };
};

export default BrainPlugin;
