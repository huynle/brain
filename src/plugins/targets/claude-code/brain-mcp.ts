#!/usr/bin/env bun
/**
 * Brain API MCP Server for Claude Code
 *
 * An MCP (Model Context Protocol) server that exposes Brain API tools to Claude Code.
 * This allows Claude Code to use brain_save, brain_recall, brain_search, etc.
 *
 * Configuration:
 * - BRAIN_API_URL: Base URL for the Brain API (default: http://localhost:3333)
 *
 * This file is auto-generated by brain. Do not edit directly.
 * Source: https://github.com/huynle/brain
 * Generated: {{GENERATED_DATE}}
 *
 * Usage:
 *   Add to your Claude Code MCP config:
 *   {
 *     "mcpServers": {
 *       "brain": {
 *         "command": "bun",
 *         "args": ["run", "/path/to/brain-mcp.ts"],
 *         "env": { "BRAIN_API_URL": "http://localhost:3333" }
 *       }
 *     }
 *   }
 */

import { execSync } from "child_process";
import { homedir } from "os";

// ============================================================================
// Types
// ============================================================================

type BrainEntryType =
  | "summary"
  | "report"
  | "walkthrough"
  | "plan"
  | "pattern"
  | "learning"
  | "idea"
  | "scratch"
  | "decision"
  | "exploration"
  | "execution"
  | "task";

type BrainEntryStatus =
  | "draft"
  | "pending"
  | "active"
  | "in_progress"
  | "blocked"
  | "completed"
  | "validated"
  | "superseded"
  | "archived";

const ENTRY_TYPES: BrainEntryType[] = [
  "summary", "report", "walkthrough", "plan", "pattern", "learning",
  "idea", "scratch", "decision", "exploration", "execution", "task",
];

const ENTRY_STATUSES: BrainEntryStatus[] = [
  "draft", "pending", "active", "in_progress", "blocked",
  "completed", "validated", "superseded", "archived",
];

// ============================================================================
// Configuration
// ============================================================================

const BRAIN_API_URL = process.env.BRAIN_API_URL || "http://localhost:3333";

// ============================================================================
// Health Check & Connection State
// ============================================================================

interface BrainConnectionState {
  available: boolean;
  lastCheck: number;
  lastError?: string;
  version?: string;
}

let connectionState: BrainConnectionState = {
  available: false,
  lastCheck: 0,
};

const HEALTH_CHECK_INTERVAL_MS = 30_000; // Re-check every 30 seconds when healthy
const HEALTH_CHECK_RETRY_MS = 5_000; // Re-check every 5 seconds when unhealthy (faster reconnect)

async function checkBrainHealth(): Promise<BrainConnectionState> {
  const now = Date.now();
  
  // Use shorter retry interval when unhealthy for faster reconnect
  const cacheInterval = connectionState.available 
    ? HEALTH_CHECK_INTERVAL_MS 
    : HEALTH_CHECK_RETRY_MS;
  
  if (now - connectionState.lastCheck < cacheInterval) {
    return connectionState;
  }

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    
    const response = await fetch(`${BRAIN_API_URL}/health`, {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    if (response.ok) {
      const data = await response.json();
      connectionState = {
        available: true,
        lastCheck: now,
        version: data.version,
      };
    } else {
      connectionState = {
        available: false,
        lastCheck: now,
        lastError: `Server returned ${response.status}: ${response.statusText}`,
      };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionRefused = errorMessage.includes("ECONNREFUSED") || 
                                 errorMessage.includes("fetch failed") ||
                                 errorMessage.includes("aborted");
    
    connectionState = {
      available: false,
      lastCheck: now,
      lastError: isConnectionRefused 
        ? `Cannot connect to Brain API at ${BRAIN_API_URL}. Start with: brain start`
        : `Health check failed: ${errorMessage}`,
    };
  }

  return connectionState;
}

function formatUnavailableMessage(): string {
  return `BRAIN API UNAVAILABLE

The Brain API server is not reachable at ${BRAIN_API_URL}.
Error: ${connectionState.lastError || "Unknown error"}

To fix: Run "brain start" to start the server.
Brain tools will not work until the server is running.`;
}

// ============================================================================
// Execution Context
// ============================================================================

interface ExecutionContext {
  projectId: string;
  workdir: string;
  worktree?: string;
  gitRemote?: string;
  gitBranch?: string;
}

function getExecutionContext(directory: string): ExecutionContext {
  const home = homedir();
  let mainWorktreePath = directory;
  let currentWorktreePath: string | undefined;
  let gitRemote: string | undefined;
  let gitBranch: string | undefined;

  try {
    const worktreeList = execSync("git worktree list --porcelain", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    const lines = worktreeList.split("\n");
    const firstWorktreeLine = lines.find((l) => l.startsWith("worktree "));
    if (firstWorktreeLine) {
      mainWorktreePath = firstWorktreeLine.replace("worktree ", "");
    }

    if (directory !== mainWorktreePath) {
      currentWorktreePath = directory;
    }

    gitRemote = execSync("git remote get-url origin", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();

    gitBranch = execSync("git branch --show-current", {
      cwd: directory,
      encoding: "utf-8",
    }).trim();
  } catch {
    // Not a git repo
  }

  const makeHomeRelative = (path: string): string => {
    if (path.startsWith(home)) {
      return path.slice(home.length + 1);
    }
    return path;
  };

  return {
    projectId: makeHomeRelative(mainWorktreePath),
    workdir: makeHomeRelative(mainWorktreePath),
    worktree: currentWorktreePath ? makeHomeRelative(currentWorktreePath) : undefined,
    gitRemote,
    gitBranch,
  };
}

// ============================================================================
// API Client
// ============================================================================

interface ApiError {
  error: string;
  message: string;
  details?: unknown;
}

async function apiRequest<T>(
  method: string,
  path: string,
  body?: unknown,
  queryParams?: Record<string, string | number | boolean | undefined>
): Promise<T> {
  // Check health before making request
  const health = await checkBrainHealth();
  if (!health.available) {
    throw new Error(formatUnavailableMessage());
  }

  let url = `${BRAIN_API_URL}/api/v1${path}`;

  if (queryParams) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(queryParams)) {
      if (value !== undefined) {
        params.append(key, String(value));
      }
    }
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }
  }

  const options: RequestInit = {
    method,
    headers: { "Content-Type": "application/json" },
  };

  if (body && (method === "POST" || method === "PATCH" || method === "PUT")) {
    options.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url, options);

    if (!response.ok) {
      let errorData: ApiError;
      try {
        errorData = await response.json();
      } catch {
        errorData = {
          error: "API Error",
          message: `HTTP ${response.status}: ${response.statusText}`,
        };
      }
      throw new Error(errorData.message || `API error: ${response.status}`);
    }

    return response.json();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isConnectionError = errorMessage.includes("ECONNREFUSED") || 
                              errorMessage.includes("fetch failed");
    
    if (isConnectionError) {
      connectionState = {
        available: false,
        lastCheck: Date.now(),
        lastError: `Connection lost: ${errorMessage}`,
      };
      throw new Error(formatUnavailableMessage());
    }
    
    throw error;
  }
}

// ============================================================================
// MCP Protocol Types
// ============================================================================

interface MCPRequest {
  jsonrpc: "2.0";
  id: number | string;
  method: string;
  params?: unknown;
}

interface MCPResponse {
  jsonrpc: "2.0";
  id: number | string;
  result?: unknown;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

interface MCPNotification {
  jsonrpc: "2.0";
  method: string;
  params?: unknown;
}

interface Tool {
  name: string;
  description: string;
  inputSchema: {
    type: "object";
    properties: Record<string, unknown>;
    required?: string[];
  };
}

// ============================================================================
// Tool Definitions
// ============================================================================

const tools: Tool[] = [
  {
    name: "brain_save",
    description: `Save content to the brain for future reference. Use this to persist:
- summaries: Session summaries, key decisions made
- reports: Analysis reports, code reviews, investigations
- walkthroughs: Code explanations, architecture overviews
- plans: Implementation plans, designs, roadmaps
- patterns: Reusable patterns discovered (use global:true for cross-project)
- learnings: General learnings, best practices (use global:true for cross-project)
- ideas: Ideas for future exploration
- scratch: Temporary working notes
- decision: Architectural decisions, ADRs
- exploration: Investigation notes, research findings`,
    inputSchema: {
      type: "object",
      properties: {
        type: { type: "string", enum: ENTRY_TYPES, description: "Type of content being saved" },
        title: { type: "string", description: "Short descriptive title for the entry" },
        content: { type: "string", description: "The content to save (markdown supported)" },
        tags: { type: "array", items: { type: "string" }, description: "Tags for categorization" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Initial status" },
        priority: { type: "string", enum: ["high", "medium", "low"], description: "Priority level" },
        global: { type: "boolean", description: "Save to global brain (cross-project)" },
        project: { type: "string", description: "Explicit project ID/name" },
        depends_on: { type: "array", items: { type: "string" }, description: "Task dependencies - list of task IDs or titles" },
        user_original_request: { type: "string", description: "Verbatim user request for this task. HIGHLY RECOMMENDED for tasks - enables validation during task completion. Supports multiline content, code blocks, and special characters. When creating multiple tasks from one user request, include this in EACH task." },
      },
      required: ["type", "title", "content"],
    },
  },
  {
    name: "brain_recall",
    description: "Retrieve a specific entry from the brain by path, ID, or title.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path or ID to the note" },
        title: { type: "string", description: "Title to search for (exact match)" },
      },
    },
  },
  {
    name: "brain_search",
    description: "Search the brain using full-text search.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "Search query" },
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Filter by status" },
        limit: { type: "number", description: "Maximum results (default: 10)" },
        global: { type: "boolean", description: "Search only global entries" },
      },
      required: ["query"],
    },
  },
  {
    name: "brain_list",
    description: "List entries in the brain with optional filtering.",
    inputSchema: {
      type: "object",
      properties: {
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "Filter by status" },
        limit: { type: "number", description: "Maximum entries to return (default: 20)" },
        global: { type: "boolean", description: "List only global entries" },
        sortBy: { type: "string", enum: ["created", "modified", "priority"], description: "Sort order" },
      },
    },
  },
  {
    name: "brain_inject",
    description: "Search the brain and return relevant context for a task.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "What context are you looking for?" },
        maxEntries: { type: "number", description: "Maximum entries to include (default: 5)" },
        type: { type: "string", enum: ENTRY_TYPES, description: "Filter by entry type" },
      },
      required: ["query"],
    },
  },
  {
    name: "brain_update",
    description: "Update an existing brain entry's status, title, or append content.",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to the entry to update" },
        status: { type: "string", enum: ENTRY_STATUSES, description: "New status" },
        title: { type: "string", description: "New title" },
        append: { type: "string", description: "Content to append" },
        note: { type: "string", description: "Short note to add" },
      },
      required: ["path"],
    },
  },
  {
    name: "brain_stats",
    description: "Get statistics about the brain storage.",
    inputSchema: {
      type: "object",
      properties: {
        global: { type: "boolean", description: "Show only global entries stats" },
      },
    },
  },
  {
    name: "brain_check_connection",
    description: `Check if the Brain API server is running and accessible.

Use this tool FIRST if you're unsure whether brain tools will work.
Returns connection status, server version, and helpful troubleshooting info if unavailable.

This is useful to:
- Verify the brain is available before starting a task that needs it
- Diagnose why other brain tools are failing
- Get instructions for starting the brain server`,
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
];

// ============================================================================
// Tool Handlers
// ============================================================================

const context = getExecutionContext(process.cwd());

async function handleToolCall(name: string, args: Record<string, unknown>): Promise<string> {
  try {
    switch (name) {
      case "brain_save": {
        const response = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          link: string;
        }>("POST", "/entries", {
          ...args,
          project: args.project || context.projectId,
          workdir: args.type === "task" ? context.workdir : undefined,
          worktree: args.type === "task" ? context.worktree : undefined,
          git_remote: args.type === "task" ? context.gitRemote : undefined,
          git_branch: args.type === "task" ? context.gitBranch : undefined,
          // Only include user_original_request for tasks
          user_original_request:
            args.type === "task" ? args.user_original_request : undefined,
        });
        return `Saved to brain\n\nPath: ${response.path}\nID: ${response.id}\nTitle: ${response.title}\nType: ${response.type}\nStatus: ${response.status}`;
      }

      case "brain_recall": {
        let entryPath = args.path as string | undefined;
        if (!entryPath && args.title) {
          const searchResult = await apiRequest<{
            results: Array<{ path: string; title: string }>;
          }>("POST", "/search", { query: args.title, limit: 5 });
          const exactMatch = searchResult.results.find((r) => r.title === args.title);
          if (exactMatch) {
            entryPath = exactMatch.path;
          } else {
            return `No exact match for: "${args.title}"`;
          }
        }
        if (!entryPath) return "Please provide a path or title";
        
        const response = await apiRequest<{
          id: string;
          path: string;
          title: string;
          type: string;
          status: string;
          content: string;
          tags: string[];
          user_original_request?: string;
        }>("GET", `/entries/${entryPath}`);
        const userRequest = response.user_original_request ? `\nUser Original Request: ${response.user_original_request}` : "";
        return `## ${response.title}\n\nPath: ${response.path}\nType: ${response.type}\nStatus: ${response.status}\nTags: ${response.tags?.join(", ") || "none"}${userRequest}\n\n---\n\n${response.content}`;
      }

      case "brain_search": {
        const response = await apiRequest<{
          results: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
            status: string;
            snippet: string;
          }>;
          total: number;
        }>("POST", "/search", args);
        if (response.results.length === 0) {
          return `No entries found matching "${args.query}"`;
        }
        const lines = [`Found ${response.total} entries:\n`];
        for (const result of response.results) {
          lines.push(`- **${result.title}** (${result.path}) - ${result.type}`);
          if (result.snippet) lines.push(`  > ${result.snippet}...`);
        }
        return lines.join("\n");
      }

      case "brain_list": {
        const response = await apiRequest<{
          entries: Array<{
            id: string;
            path: string;
            title: string;
            type: string;
            status: string;
            priority?: string;
          }>;
          total: number;
        }>("GET", "/entries", undefined, args as Record<string, string | number | boolean | undefined>);
        if (response.entries.length === 0) {
          return "No entries found";
        }
        const lines = [`Found ${response.total} entries:\n`];
        for (const entry of response.entries) {
          lines.push(`- **${entry.title}** (${entry.path}) - ${entry.type} | ${entry.status}`);
        }
        return lines.join("\n");
      }

      case "brain_inject": {
        const response = await apiRequest<{
          context: string;
          entries: Array<{ id: string; path: string; title: string; type: string }>;
        }>("POST", "/inject", args);
        if (!response.context || response.entries.length === 0) {
          return `No relevant context found for "${args.query}"`;
        }
        return response.context;
      }

      case "brain_update": {
        const response = await apiRequest<{
          path: string;
          title: string;
          status: string;
        }>("PATCH", `/entries/${args.path}`, args);
        return `Updated: ${response.path}\nStatus: ${response.status}\nTitle: ${response.title}`;
      }

      case "brain_stats": {
        const response = await apiRequest<{
          totalEntries: number;
          globalEntries: number;
          projectEntries: number;
          byType: Record<string, number>;
        }>("GET", "/stats", undefined, args as Record<string, string | number | boolean | undefined>);
        const lines = [
          "## Brain Statistics\n",
          `Total: ${response.totalEntries}`,
          `Global: ${response.globalEntries}`,
          `Project: ${response.projectEntries}`,
          "\n### By Type",
        ];
        for (const [type, count] of Object.entries(response.byType).sort((a, b) => b[1] - a[1])) {
          lines.push(`- ${type}: ${count}`);
        }
        return lines.join("\n");
      }

      case "brain_check_connection": {
        // Force a fresh health check
        connectionState.lastCheck = 0;
        const health = await checkBrainHealth();

        if (health.available) {
          return `Brain API Status: CONNECTED

Server URL: ${BRAIN_API_URL}
Version: ${health.version || "unknown"}
Status: Ready to use

All brain tools (save, recall, search, inject, etc.) are available.`;
        } else {
          return `Brain API Status: UNAVAILABLE

Server URL: ${BRAIN_API_URL}
Error: ${health.lastError || "Unknown error"}

To start the Brain API server:
  brain start

To check server status:
  brain status

Brain tools will not work until the server is running.`;
        }
      }

      default:
        return `Unknown tool: ${name}`;
    }
  } catch (error) {
    return `Error: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// ============================================================================
// MCP Server
// ============================================================================

function sendResponse(response: MCPResponse | MCPNotification): void {
  const json = JSON.stringify(response);
  process.stdout.write(`Content-Length: ${Buffer.byteLength(json)}\r\n\r\n${json}`);
}

async function handleRequest(request: MCPRequest): Promise<void> {
  let result: unknown;

  switch (request.method) {
    case "initialize":
      result = {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {},
        },
        serverInfo: {
          name: "brain-mcp",
          version: "1.0.0",
        },
      };
      break;

    case "tools/list":
      result = { tools };
      break;

    case "tools/call": {
      const params = request.params as { name: string; arguments?: Record<string, unknown> };
      const content = await handleToolCall(params.name, params.arguments || {});
      result = {
        content: [{ type: "text", text: content }],
      };
      break;
    }

    default:
      sendResponse({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32601,
          message: `Method not found: ${request.method}`,
        },
      });
      return;
  }

  sendResponse({
    jsonrpc: "2.0",
    id: request.id,
    result,
  });
}

// ============================================================================
// Main
// ============================================================================

async function main(): Promise<void> {
  let buffer = "";

  process.stdin.setEncoding("utf-8");
  process.stdin.on("data", async (chunk: string) => {
    buffer += chunk;

    while (true) {
      const headerEnd = buffer.indexOf("\r\n\r\n");
      if (headerEnd === -1) break;

      const header = buffer.slice(0, headerEnd);
      const contentLengthMatch = header.match(/Content-Length: (\d+)/i);
      if (!contentLengthMatch) {
        buffer = buffer.slice(headerEnd + 4);
        continue;
      }

      const contentLength = parseInt(contentLengthMatch[1], 10);
      const contentStart = headerEnd + 4;
      const contentEnd = contentStart + contentLength;

      if (buffer.length < contentEnd) break;

      const content = buffer.slice(contentStart, contentEnd);
      buffer = buffer.slice(contentEnd);

      try {
        const request = JSON.parse(content) as MCPRequest;
        await handleRequest(request);
      } catch (error) {
        console.error("Parse error:", error);
      }
    }
  });

  process.stdin.on("end", () => {
    process.exit(0);
  });
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
