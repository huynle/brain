#!/usr/bin/env bash
#
# do-work-deps - Unified task queue processor with dependency support
#
# This is a complete task processing system that:
# 1. Resolves task dependencies (using zk/brain metadata)
# 2. Only processes tasks when all dependencies are completed
# 3. Detects circular dependencies
# 4. Spawns OpenCode to process ready tasks
# 5. Monitors and re-evaluates dependencies after each task completes
#
# Usage:
#   do-work-deps start <project-id> [--foreground] [--tui]  - Start processing tasks
#   do-work-deps run-one <project-id> [--all]               - Execute single highest-priority task
#   do-work-deps stop [project-id]                          - Stop monitor(s)
#   do-work-deps status [project-id]                        - Show status
#   do-work-deps list <project-id>                          - List all tasks
#   do-work-deps ready <project-id>                         - List ready tasks
#   do-work-deps waiting <project-id>                       - List waiting tasks
#   do-work-deps blocked <project-id>                       - List blocked tasks
#   do-work-deps graph <project-id>                         - Show dependency graph
#   do-work-deps logs [-f]                                  - Show logs
#
# Environment:
#   DO_WORK_POLL_INTERVAL  - Seconds between polls (default: 30)
#   DO_WORK_BRAIN_DIR      - Brain directory (default: ~/docs/brain)
#

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly VERSION="1.0.0"
readonly SCRIPT_NAME="do-work-deps"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Directories - use local experiment dirs by default, but allow override
readonly CONFIG_DIR="${HOME}/.config/do-work-deps"
readonly STATE_DIR="${HOME}/.local/state/do-work-deps"
readonly LOG_DIR="${HOME}/.local/log"
readonly RUN_DIR="${HOME}/.local/run"

# Files
readonly CONFIG_FILE="${CONFIG_DIR}/config"
readonly LOG_FILE="${LOG_DIR}/do-work-deps.log"

# Get per-project state file path
get_state_file() {
  local project_id="$1"
  echo "${STATE_DIR}/monitor-${project_id}.json"
}

# Get per-project PID file path
get_pid_file() {
  local project_id="$1"
  echo "${RUN_DIR}/do-work-deps-${project_id}.pid"
}

# Get per-project spawned PIDs file path (for cleanup)
get_spawned_pids_file() {
  local project_id="$1"
  echo "${STATE_DIR}/spawned_pids_${project_id}.txt"
}

# Defaults (can be overridden by config or env)
# Use global brain by default (same as brain_save tool)
BRAIN_DIR="${DO_WORK_BRAIN_DIR:-${HOME}/docs/brain}"
POLL_INTERVAL="${DO_WORK_POLL_INTERVAL:-30}"
AGENT="general"
MODEL="${DO_WORK_MODEL:-anthropic/claude-opus-4-5}"
OPENCODE_BIN="${OPENCODE_BIN:-opencode}"
DEFAULT_PROJECT="test"

# Parallel execution settings
MAX_PARALLEL="${DO_WORK_MAX_PARALLEL:-3}"           # Max concurrent tasks
TASK_POLL_INTERVAL="${DO_WORK_TASK_POLL_INTERVAL:-5}"  # Interval to check task completion (seconds)

# Multi-project settings
EXCLUDE_PATTERNS=()  # Array of glob patterns to exclude projects

# Runtime state (defaults: foreground + opencode run for automatic completion)
USE_TUI=false       # Default to 'opencode run' mode (auto-exits on completion)
FOREGROUND=true
BACKGROUND=false    # When true, run completely detached (no pane visibility)
DRY_RUN=false
WORK_DIR=""
CURRENT_PROJECT_ID=""
DASHBOARD_WINDOW_NAME=""  # Track dashboard window for cleanup

# Associative arrays for tracking running tasks (bash 4+)
declare -A RUNNING_TASKS_PID      # task_id -> pid
declare -A RUNNING_TASKS_PANE     # task_id -> pane_id
declare -A RUNNING_TASKS_PATH     # task_id -> task_path
declare -A RUNNING_TASKS_TITLE    # task_id -> title
declare -A RUNNING_TASKS_STARTED  # task_id -> start timestamp
declare -A RUNNING_TASKS_PROJECT  # task_id -> project_id

# Stats
COMPLETED_COUNT=0
FAILED_COUNT=0
MONITOR_STARTED_AT=""

# =============================================================================
# Utility Functions
# =============================================================================

# Colors (only if terminal supports it)
if [[ -t 1 ]]; then
  readonly RED='\033[0;31m'
  readonly GREEN='\033[0;32m'
  readonly YELLOW='\033[0;33m'
  readonly BLUE='\033[0;34m'
  readonly MAGENTA='\033[0;35m'
  readonly CYAN='\033[0;36m'
  readonly BOLD='\033[1m'
  readonly DIM='\033[2m'
  readonly RESET='\033[0m'
else
  readonly RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN='' BOLD='' DIM='' RESET=''
fi

log() {
  local level="$1"
  shift
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local message="[${timestamp}] [${level}] $*"
  
  # Create log dir if needed
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Always write to log file
  echo "$message" >> "$LOG_FILE"
  
  # Also print to stderr if in foreground mode or if it's an error
  if [[ "$FOREGROUND" == "true" ]] || [[ "$level" == "ERROR" ]]; then
    case "$level" in
      INFO)  echo -e "${GREEN}${message}${RESET}" >&2 ;;
      WARN)  echo -e "${YELLOW}${message}${RESET}" >&2 ;;
      ERROR) echo -e "${RED}${message}${RESET}" >&2 ;;
      DEBUG) echo -e "${DIM}${message}${RESET}" >&2 ;;
      *)     echo "$message" >&2 ;;
    esac
  fi
}

die() {
  echo -e "${RED}Error: $*${RESET}" >&2
  exit 1
}

debug() {
  if [[ "${DEBUG:-}" == "true" ]]; then
    echo -e "${DIM}[DEBUG] $*${RESET}" >&2
  fi
}

ensure_dirs() {
  mkdir -p "$CONFIG_DIR" "$STATE_DIR" "$LOG_DIR" "$RUN_DIR"
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
  fi
}

# =============================================================================
# Workdir Resolution
# =============================================================================

# Resolve a $HOME-relative workdir to an absolute path
# Falls back to current directory if resolution fails
resolve_workdir() {
  local workdir="$1"
  local worktree="$2"
  local git_remote="$3"
  
  # If no workdir specified, use current directory
  if [[ -z "$workdir" ]]; then
    pwd
    return 0
  fi
  
  # Try worktree first if specified (more specific)
  if [[ -n "$worktree" ]]; then
    local worktree_path="${HOME}/${worktree}"
    if [[ -d "$worktree_path" ]]; then
      echo "$worktree_path"
      return 0
    fi
    log WARN "Worktree not found: $worktree_path, falling back to workdir"
  fi
  
  # Try main workdir
  local workdir_path="${HOME}/${workdir}"
  if [[ -d "$workdir_path" ]]; then
    echo "$workdir_path"
    return 0
  fi
  
  # If git_remote is provided, try to find repo by remote
  if [[ -n "$git_remote" ]]; then
    log INFO "Workdir not found at $workdir_path, searching by git remote..."
    local found_path
    found_path=$(find_repo_by_remote "$git_remote")
    if [[ -n "$found_path" ]]; then
      log INFO "Found repo at: $found_path"
      echo "$found_path"
      return 0
    fi
  fi
  
  log WARN "Could not resolve workdir: $workdir, using current directory"
  pwd
  return 1
}

# Find a git repository by its remote URL
# Searches common locations: ~, ~/projects, ~/code, ~/work
find_repo_by_remote() {
  local target_remote="$1"
  local search_dirs=("$HOME" "$HOME/projects" "$HOME/code" "$HOME/work")
  
  for search_dir in "${search_dirs[@]}"; do
    [[ ! -d "$search_dir" ]] && continue
    
    # Find .git directories (max depth 3 to avoid deep recursion)
    while IFS= read -r git_dir; do
      local repo_dir
      repo_dir=$(dirname "$git_dir")
      local repo_remote
      repo_remote=$(git -C "$repo_dir" remote get-url origin 2>/dev/null || true)
      
      if [[ "$repo_remote" == "$target_remote" ]]; then
        echo "$repo_dir"
        return 0
      fi
    done < <(find "$search_dir" -maxdepth 4 -name ".git" -type d 2>/dev/null)
  done
  
  return 1
}

# =============================================================================
# Project Discovery (for multi-project mode)
# =============================================================================

# Check if project should be excluded based on patterns
should_exclude_project() {
  local project_id="$1"
  for pattern in "${EXCLUDE_PATTERNS[@]}"; do
    # Use bash glob matching
    if [[ "$project_id" == $pattern ]]; then
      return 0  # exclude
    fi
  done
  return 1  # include
}

# Discover all projects with task directories
discover_projects() {
  local projects_dir="${BRAIN_DIR}/projects"
  
  if [[ ! -d "$projects_dir" ]]; then
    return
  fi
  
  for dir in "$projects_dir"/*/task; do
    if [[ -d "$dir" ]]; then
      local project_id
      project_id=$(basename "$(dirname "$dir")")
      if ! should_exclude_project "$project_id"; then
        echo "$project_id"
      fi
    fi
  done
}

# =============================================================================
# State Management
# =============================================================================

save_state() {
  local project_id="$1"
  local status="$2"
  local current_task="${3:-}"
  local task_title="${4:-}"
  local task_priority="${5:-}"
  local task_started="${6:-}"
  local opencode_pid="${7:-}"
  
  local now
  now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local state_file
  state_file=$(get_state_file "$project_id")
  
  cat > "$state_file" << EOF
{
  "project_id": "${project_id}",
  "status": "${status}",
  "workdir": "${WORK_DIR:-$(pwd)}",
  "agent": "${AGENT}",
  "model": "${MODEL}",
  "use_tui": ${USE_TUI},
  "poll_interval": ${POLL_INTERVAL},
  "started_at": "${MONITOR_STARTED_AT:-$now}",
  "updated_at": "${now}",
  "current_task": {
    "path": "${current_task}",
    "title": "${task_title}",
    "priority": "${task_priority}",
    "started_at": "${task_started}",
    "opencode_pid": "${opencode_pid}"
  },
  "stats": {
    "completed": ${COMPLETED_COUNT:-0},
    "failed": ${FAILED_COUNT:-0}
  }
}
EOF
}

load_state() {
  local project_id="$1"
  local state_file
  state_file=$(get_state_file "$project_id")
  if [[ -f "$state_file" ]]; then
    cat "$state_file"
  else
    echo "{}"
  fi
}

clear_state() {
  local project_id="$1"
  local state_file
  state_file=$(get_state_file "$project_id")
  rm -f "$state_file"
}

# =============================================================================
# Running Tasks Tracking (for parallel execution)
# =============================================================================

# Get file path for persisting running tasks state
get_running_tasks_file() {
  local project_id="$1"
  echo "${STATE_DIR}/running_tasks_${project_id}.json"
}

# Add a task to the running set
add_running_task() {
  local task_id="$1"
  local task_path="$2"
  local task_title="$3"
  local pid="$4"
  local pane_id="${5:-}"
  local project="${6:-$CURRENT_PROJECT_ID}"
  
  local now
  now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  RUNNING_TASKS_PID["$task_id"]="$pid"
  RUNNING_TASKS_PANE["$task_id"]="$pane_id"
  RUNNING_TASKS_PATH["$task_id"]="$task_path"
  RUNNING_TASKS_TITLE["$task_id"]="$task_title"
  RUNNING_TASKS_STARTED["$task_id"]="$now"
  RUNNING_TASKS_PROJECT["$task_id"]="$project"
  
  # Persist to file for state recovery
  persist_running_tasks
  
  log INFO "Added running task: $task_title (id: $task_id, pid: $pid, project: $project)"
}

# Remove a task from the running set
remove_running_task() {
  local task_id="$1"
  
  local title="${RUNNING_TASKS_TITLE[$task_id]:-unknown}"
  
  unset "RUNNING_TASKS_PID[$task_id]"
  unset "RUNNING_TASKS_PANE[$task_id]"
  unset "RUNNING_TASKS_PATH[$task_id]"
  unset "RUNNING_TASKS_TITLE[$task_id]"
  unset "RUNNING_TASKS_STARTED[$task_id]"
  unset "RUNNING_TASKS_PROJECT[$task_id]"
  
  persist_running_tasks
  
  log INFO "Removed running task: $title (id: $task_id)"
}

# Get count of currently running tasks
get_running_task_count() {
  echo "${#RUNNING_TASKS_PID[@]}"
}

# Get list of running task IDs
get_running_task_ids() {
  echo "${!RUNNING_TASKS_PID[@]}"
}

# Check if a task is currently running
is_task_running() {
  local task_id="$1"
  [[ -n "${RUNNING_TASKS_PID[$task_id]:-}" ]]
}

# Persist running tasks to file
persist_running_tasks() {
  local project_id="${CURRENT_PROJECT_ID:-}"
  [[ -z "$project_id" ]] && return
  
  local running_file
  running_file=$(get_running_tasks_file "$project_id")
  
  local tasks_json="["
  local first=true
  
  for task_id in "${!RUNNING_TASKS_PID[@]}"; do
    if [[ "$first" != "true" ]]; then
      tasks_json+=","
    fi
    first=false
    
    tasks_json+=$(cat <<EOF
{
  "id": "${task_id}",
  "path": "${RUNNING_TASKS_PATH[$task_id]}",
  "title": "${RUNNING_TASKS_TITLE[$task_id]}",
  "pid": ${RUNNING_TASKS_PID[$task_id]},
  "pane_id": "${RUNNING_TASKS_PANE[$task_id]:-}",
  "started_at": "${RUNNING_TASKS_STARTED[$task_id]}",
  "project": "${RUNNING_TASKS_PROJECT[$task_id]:-$project_id}"
}
EOF
)
  done
  
  tasks_json+="]"
  echo "$tasks_json" > "$running_file"
}

# Load running tasks from file (for recovery after restart)
load_running_tasks() {
  local project_id="$1"
  local running_file
  running_file=$(get_running_tasks_file "$project_id")
  
  # Clear existing state
  RUNNING_TASKS_PID=()
  RUNNING_TASKS_PANE=()
  RUNNING_TASKS_PATH=()
  RUNNING_TASKS_TITLE=()
  RUNNING_TASKS_STARTED=()
  RUNNING_TASKS_PROJECT=()
  
  if [[ ! -f "$running_file" ]]; then
    return
  fi
  
  local tasks_json
  tasks_json=$(cat "$running_file")
  
  local count
  count=$(echo "$tasks_json" | jq 'length')
  
  for ((i=0; i<count; i++)); do
    local task
    task=$(echo "$tasks_json" | jq -r ".[$i]")
    
    local task_id pid pane_id path title started_at task_project
    task_id=$(echo "$task" | jq -r '.id')
    pid=$(echo "$task" | jq -r '.pid')
    pane_id=$(echo "$task" | jq -r '.pane_id // ""')
    path=$(echo "$task" | jq -r '.path')
    title=$(echo "$task" | jq -r '.title')
    started_at=$(echo "$task" | jq -r '.started_at')
    task_project=$(echo "$task" | jq -r '.project // ""')
    
    # Only restore if process is still running
    if kill -0 "$pid" 2>/dev/null; then
      RUNNING_TASKS_PID["$task_id"]="$pid"
      RUNNING_TASKS_PANE["$task_id"]="$pane_id"
      RUNNING_TASKS_PATH["$task_id"]="$path"
      RUNNING_TASKS_TITLE["$task_id"]="$title"
      RUNNING_TASKS_STARTED["$task_id"]="$started_at"
      RUNNING_TASKS_PROJECT["$task_id"]="${task_project:-$project_id}"
      log INFO "Restored running task: $title (id: $task_id, pid: $pid)"
    else
      log WARN "Task process no longer running, will not restore: $title (pid: $pid)"
    fi
  done
}

# Clear all running tasks (for shutdown)
clear_running_tasks() {
  RUNNING_TASKS_PID=()
  RUNNING_TASKS_PANE=()
  RUNNING_TASKS_PATH=()
  RUNNING_TASKS_TITLE=()
  RUNNING_TASKS_STARTED=()
  RUNNING_TASKS_PROJECT=()
  
  local project_id="${CURRENT_PROJECT_ID:-}"
  if [[ -n "$project_id" ]]; then
    local running_file
    running_file=$(get_running_tasks_file "$project_id")
    rm -f "$running_file"
  fi
}

# Get running tasks as JSON (for status display)
get_running_tasks_json() {
  local tasks_json="["
  local first=true
  
  for task_id in "${!RUNNING_TASKS_PID[@]}"; do
    if [[ "$first" != "true" ]]; then
      tasks_json+=","
    fi
    first=false
    
    local elapsed=""
    if [[ -n "${RUNNING_TASKS_STARTED[$task_id]:-}" ]]; then
      local start_ts
      start_ts=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "${RUNNING_TASKS_STARTED[$task_id]}" "+%s" 2>/dev/null || echo "0")
      local now_ts
      now_ts=$(date "+%s")
      local elapsed_sec=$((now_ts - start_ts))
      elapsed="${elapsed_sec}s"
      if [[ $elapsed_sec -ge 60 ]]; then
        elapsed="$((elapsed_sec / 60))m $((elapsed_sec % 60))s"
      fi
    fi
    
    tasks_json+=$(cat <<EOF
{
  "id": "${task_id}",
  "title": "${RUNNING_TASKS_TITLE[$task_id]}",
  "pid": ${RUNNING_TASKS_PID[$task_id]},
  "pane_id": "${RUNNING_TASKS_PANE[$task_id]:-}",
  "elapsed": "${elapsed}",
  "project": "${RUNNING_TASKS_PROJECT[$task_id]:-}"
}
EOF
)
  done
  
  tasks_json+="]"
  echo "$tasks_json"
}

# =============================================================================
# Task Queries (Basic)
# =============================================================================

# Query all tasks - supports "all" to query across all projects
query_all_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  if [[ "$project_id" == "all" ]]; then
    local combined="[]"
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      local proj_tasks
      proj_tasks=$(query_all_tasks_single "$proj")
      # Add project field to each task
      combined=$(echo "$combined" "$proj_tasks" | jq -s --arg p "$proj" '.[0] + (.[1] | map(. + {project: $p}))')
    done < <(discover_projects)
    echo "$combined"
    return
  fi
  
  query_all_tasks_single "$project_id"
}

# Query all tasks for a single project (raw, no dependency resolution)
query_all_tasks_single() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local project_dir="projects/${project_id}/task"
  
  debug "Querying all tasks for project: $project_id"
  
  if ! command -v zk &> /dev/null; then
    die "zk CLI not found. Install from https://github.com/zk-org/zk"
  fi
  
  # Ensure zk index is up to date
  zk index --notebook-dir "$BRAIN_DIR" --quiet 2>/dev/null || true
  
  # Query for task entries
  local result
  result=$(zk list \
    --notebook-dir "$BRAIN_DIR" \
    --format json \
    --quiet \
    --tag task \
    "$project_dir" 2>/dev/null || echo "[]")
  
  # Extract task data including depends_on, parent_id, and workdir fields - output as JSON array
  echo "$result" | jq -c --arg proj "$project_id" '
    [.[] | select(.absPath | contains("/projects/" + $proj + "/"))] |
    map({
      id: (.absPath | split("/") | last | sub("\\.md$"; "")),
      path: .absPath,
      relative_path: ("projects/" + (.absPath | split("/projects/")[1] // .absPath)),
      title: .title,
      priority: (.metadata.priority // "medium"),
      status: (.metadata.status // "pending"),
      depends_on: (.metadata.depends_on // []),
      parent_id: (.metadata.parent_id // null),
      created: (.created // ""),
      workdir: (.metadata.workdir // null),
      worktree: (.metadata.worktree // null),
      git_remote: (.metadata.git_remote // null),
      git_branch: (.metadata.git_branch // null)
    })
  ' 2>/dev/null || echo "[]"
}

# Build complete task list
build_task_list() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  query_all_tasks "$project_id"
}

# Get tasks that are children of a specific parent
get_children_tasks() {
  local tasks_json="$1"
  local parent_id="$2"
  
  echo "$tasks_json" | jq -c --arg pid "$parent_id" '
    [.[] | select(.parent_id == $pid)]
  '
}

# Get tasks with no parent (root level tasks)
get_root_tasks() {
  local tasks_json="$1"
  
  echo "$tasks_json" | jq -c '
    [.[] | select(.parent_id == null or .parent_id == "")]
  '
}

# Get all parent entries (tasks that have children)
get_parent_entries() {
  local tasks_json="$1"
  
  # Find all unique parent_ids that exist
  echo "$tasks_json" | jq -c '
    # Collect all parent_ids that are referenced
    [.[].parent_id | select(. != null and . != "")] | unique as $parent_ids |
    # Return tasks whose id is in the parent_ids list
    [.[] | select(.id as $id | $parent_ids | index($id))]
  '
}

# Build hierarchical task tree structure
# Returns JSON with tasks organized by hierarchy
build_task_hierarchy() {
  local tasks_json="$1"
  
  echo "$tasks_json" | jq -c '
    # Build lookup map
    . as $all |
    (map({(.id): .}) | add // {}) as $by_id |
    
    # Find all parent IDs
    ([.[].parent_id | select(. != null and . != "")] | unique) as $parent_ids |
    
    # Recursive function to build tree (iterative approach with max depth)
    def build_children($pid; $depth):
      if $depth > 10 then [] else
        [.[] | select(.parent_id == $pid)] |
        map(. + {
          children: ($all | build_children(.id; $depth + 1)),
          depth: $depth
        })
      end;
    
    # Root tasks (no parent)
    [.[] | select(.parent_id == null or .parent_id == "")] |
    map(. + {
      children: ($all | build_children(.id; 1)),
      depth: 0
    }) |
    
    {
      root_tasks: .,
      parent_ids: $parent_ids,
      total_count: ($all | length)
    }
  '
}

# =============================================================================
# Dependency Resolution
# =============================================================================

# Resolve dependencies and classify tasks
# Includes cycle detection, transitive blocked propagation, and parent hierarchy
resolve_dependencies() {
  local tasks_json="$1"
  
  # Use jq for dependency resolution with cycle detection and parent hierarchy
  echo "$tasks_json" | jq '
    # Build lookup maps
    . as $tasks |
    (if ($tasks | length) > 0 then ($tasks | map({(.id): .}) | add) else {} end) as $by_id |
    (if ($tasks | length) > 0 then ($tasks | map({(.title): .id}) | add) else {} end) as $title_to_id |
    
    # Helper to resolve a dependency reference to an ID
    def resolve_dep($ref):
      if $by_id[$ref] then $ref
      elif $title_to_id[$ref] then $title_to_id[$ref]
      else null
      end;
    
    # Helper to get parent chain (for hierarchy)
    def get_parent_chain($task_id; $visited):
      if ($visited | index($task_id)) then []
      elif $by_id[$task_id] then
        $by_id[$task_id] as $task |
        if $task.parent_id and $task.parent_id != "" then
          [$task.parent_id] + get_parent_chain($task.parent_id; $visited + [$task_id])
        else []
        end
      else []
      end;
    
    # First pass: resolve all dependencies and parent info
    [$tasks[] | . as $task |
      (($task.depends_on // []) | map(resolve_dep(.)) | map(select(. != null))) as $resolved_deps |
      (($task.depends_on // []) | map(. as $ref | if resolve_dep($ref) then empty else $ref end)) as $unresolved_deps |
      (get_parent_chain($task.id; [])) as $parent_chain |
      $task + {
        resolved_deps: $resolved_deps,
        unresolved_deps: $unresolved_deps,
        parent_chain: $parent_chain
      }
    ] as $resolved_tasks |
    
    # Build adjacency list
    ($resolved_tasks | if length > 0 then map({(.id): .resolved_deps}) | add else {} end) as $adj |
    
    # Cycle detection: iteratively check if each task can reach itself
    def find_cycles_iterative:
      ($adj | keys) as $all_ids |
      reduce $all_ids[] as $start (
        [];
        . as $acc |
        ($adj[$start] // []) as $initial_deps |
        if ($initial_deps | length) == 0 then $acc
        else
          {frontier: $initial_deps, seen: {}, found: false, iter: 0} |
          until(.found or (.frontier | length) == 0 or .iter > 100;
            .frontier[0] as $current |
            .frontier[1:] as $rest |
            .iter = .iter + 1 |
            if $current == $start then
              .found = true
            elif .seen[$current] then
              .frontier = $rest
            else
              .seen[$current] = true |
              .frontier = ($rest + ($adj[$current] // []))
            end
          ) |
          if .found then ($acc + [$start]) else $acc end
        end
      );
    
    (find_cycles_iterative) as $tasks_in_cycles |
    
    # Build status map with circular override
    ($resolved_tasks | if length > 0 then [.[] | . as $t | {($t.id): (if ($tasks_in_cycles | index($t.id)) then "circular" else $t.status end)}] | add else {} end) as $effective_status |
    
    # Final classification with parent hierarchy consideration
    [$resolved_tasks[] | . as $task |
      (($tasks_in_cycles | index($task.id)) != null) as $is_circular |
      
      # Check if any parent is blocked/cancelled
      ($task.parent_chain | map(. as $pid | 
        ($effective_status[$pid] // "unknown") as $ps |
        select($ps == "blocked" or $ps == "cancelled" or $ps == "circular")
      )) as $blocked_parents |
      
      # Check if parent is not active/in_progress (child cannot be ready if parent is just pending)
      ($task.parent_id // "") as $direct_parent |
      (if $direct_parent != "" then
        ($effective_status[$direct_parent] // "unknown") as $ps |
        ($ps != "active" and $ps != "in_progress" and $ps != "completed")
       else false
       end) as $parent_not_active |
      
      # Find blocked dependencies (blocked, cancelled, or circular)
      ($task.resolved_deps | map(. as $dep_id | select(
        ($effective_status[$dep_id] // "unknown") as $s |
        ($s == "blocked" or $s == "cancelled" or $s == "circular")
      ))) as $blocked_by |
      
      # Find waiting dependencies (pending or in_progress, and not blocked)
      ($task.resolved_deps | map(. as $dep_id | select(
        ($effective_status[$dep_id] // "unknown") as $s |
        ($s == "pending" or $s == "in_progress")
      ))) as $waiting_on |
      
      # Classify (considering parent hierarchy)
      (if $is_circular then "circular"
       elif $task.status != "pending" then "not_pending"
       elif ($blocked_parents | length) > 0 then "blocked_by_parent"
       elif ($blocked_by | length) > 0 then "blocked"
       elif $parent_not_active then "waiting_on_parent"
       elif ($waiting_on | length) > 0 then "waiting"
       else "ready"
       end) as $classification |
      
      $task + {
        blocked_by: $blocked_by,
        blocked_parents: $blocked_parents,
        waiting_on: $waiting_on,
        classification: $classification,
        in_cycle: $is_circular
      }
    ] |
    
    {tasks: ., cycles: (if ($tasks_in_cycles | length) > 0 then [$tasks_in_cycles] else [] end)}
  '
}

# Extract just the tasks array from resolved output
get_resolved_tasks() {
  local resolved_json="$1"
  echo "$resolved_json" | jq '.tasks'
}

# Extract cycles from resolved output  
get_cycles() {
  local resolved_json="$1"
  echo "$resolved_json" | jq '.cycles'
}

# Get ready tasks (pending with all dependencies completed)
# Returns JSON array sorted by priority
get_ready_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  # Filter to ready tasks, sort by priority
  get_resolved_tasks "$resolved" | jq '
    [.[] | select(.classification == "ready")] |
    sort_by(
      if .priority == "high" then 0
      elif .priority == "medium" then 1
      else 2
      end
    )
  '
}

# Get waiting tasks (including those waiting on parent)
get_waiting_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  get_resolved_tasks "$resolved" | jq '[.[] | select(.classification == "waiting" or .classification == "waiting_on_parent")]'
}

# Get blocked tasks (including those blocked by parent)
get_blocked_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  get_resolved_tasks "$resolved" | jq '[.[] | select(.classification == "blocked" or .classification == "blocked_by_parent")]'
}

# Get circular tasks
get_circular_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  get_resolved_tasks "$resolved" | jq '[.[] | select(.classification == "circular")]'
}

# Get first ready task (highest priority ready task)
# Returns single JSON object or empty
get_next_ready_task() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local ready
  ready=$(get_ready_tasks "$project_id")
  
  # Return first task or null
  echo "$ready" | jq '.[0] // null'
}

# =============================================================================
# Interrupted Task Handling
# =============================================================================

# Query interrupted tasks - supports "all" to query across all projects
query_interrupted_tasks() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  if [[ "$project_id" == "all" ]]; then
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      local proj_tasks
      proj_tasks=$(query_interrupted_tasks_single "$proj")
      if [[ -n "$proj_tasks" ]] && [[ "$proj_tasks" != "null" ]]; then
        # Add project field to each task
        echo "$proj_tasks" | jq -c --arg p "$proj" '. + {project: $p}'
      fi
    done < <(discover_projects)
    return
  fi
  
  query_interrupted_tasks_single "$project_id"
}

query_interrupted_tasks_single() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local project_dir="projects/${project_id}/task"
  
  debug "Querying interrupted (in_progress) tasks for project: $project_id"
  
  if ! command -v zk &> /dev/null; then
    log ERROR "zk CLI not found. Install from https://github.com/zk-org/zk"
    return 1
  fi
  
  zk index --notebook-dir "$BRAIN_DIR" --quiet 2>/dev/null || true
  
  local result
  result=$(zk list \
    --notebook-dir "$BRAIN_DIR" \
    --format json \
    --quiet \
    --tag task \
    "$project_dir" 2>/dev/null || echo "[]")
  
  echo "$result" | jq -c --arg proj "$project_id" '
    [.[] | select(.metadata.status == "in_progress") | select(.absPath | contains("/projects/" + $proj + "/"))] |
    sort_by(
      if .metadata.priority == "high" then 0
      elif .metadata.priority == "medium" then 1
      elif .metadata.priority == "low" then 2
      else 1 end
    ) |
    .[] |
    {
      path: .absPath,
      relative_path: ("projects/" + (.absPath | split("/projects/")[1] // .absPath)),
      title: .title,
      priority: (.metadata.priority // "medium"),
      status: .metadata.status,
      resume_count: (.metadata.resume_count // 0)
    }
  ' 2>/dev/null || echo ""
}

check_task_interrupted() {
  local task_relative_path="$1"
  local project_id="$2"
  
  local state
  state=$(load_state "$project_id")
  
  local current_task_path current_pid
  current_task_path=$(echo "$state" | jq -r '.current_task.path // empty')
  current_pid=$(echo "$state" | jq -r '.current_task.opencode_pid // empty')
  
  if [[ "$current_task_path" == "$task_relative_path" ]] && [[ -n "$current_pid" ]] && [[ "$current_pid" != "null" ]]; then
    if kill -0 "$current_pid" 2>/dev/null; then
      debug "Task $task_relative_path has active process (PID: $current_pid)"
      return 1
    fi
  fi
  
  debug "Task $task_relative_path appears to be interrupted (no active process)"
  return 0
}

increment_resume_count() {
  local task_path="$1"
  local full_path="${BRAIN_DIR}/${task_path}"
  
  if [[ ! -f "$full_path" ]]; then
    log WARN "Cannot update resume count: file not found: $full_path"
    return 1
  fi
  
  local current_count
  current_count=$(grep -E "^resume_count:" "$full_path" 2>/dev/null | awk '{print $2}' || echo "0")
  current_count=${current_count:-0}
  
  local new_count=$((current_count + 1))
  local now
  now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  if grep -q "^resume_count:" "$full_path" 2>/dev/null; then
    sed -i '' "s/^resume_count:.*/resume_count: $new_count/" "$full_path"
  else
    sed -i '' "/^status:/a\\
resume_count: $new_count
" "$full_path"
  fi
  
  if grep -q "^last_interrupted_at:" "$full_path" 2>/dev/null; then
    sed -i '' "s/^last_interrupted_at:.*/last_interrupted_at: $now/" "$full_path"
  else
    sed -i '' "/^resume_count:/a\\
last_interrupted_at: $now
" "$full_path"
  fi
  
  debug "Updated resume_count to $new_count for $task_path"
  echo "$new_count"
}

# =============================================================================
# Display Functions
# =============================================================================

display_tasks() {
  local tasks_json="$1"
  local title="$2"
  
  local count
  count=$(echo "$tasks_json" | jq 'length')
  
  if [[ "$count" == "0" ]]; then
    echo -e "${DIM}No tasks${RESET}"
    return
  fi
  
  echo -e "${BOLD}${title} (${count}):${RESET}"
  echo ""
  
  echo "$tasks_json" | jq -r '.[] |
    (if .priority == "high" then "üî¥"
     elif .priority == "medium" then "üü°"
     else "üü¢"
     end) as $badge |
    "  \($badge) [\(.priority)] \(.title) (\(.id))"
  '
}

display_graph() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  local resolved_tasks
  resolved_tasks=$(get_resolved_tasks "$resolved")
  
  echo ""
  echo -e "${BOLD}Task Dependency Graph - Project: ${CYAN}${project_id}${RESET}"
  echo "============================================"
  echo ""
  
  # Ready tasks (ungrouped - no parent)
  local ready_ungrouped
  ready_ungrouped=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "ready" and (.parent_id == null or .parent_id == ""))]')
  local ready_ungrouped_count
  ready_ungrouped_count=$(echo "$ready_ungrouped" | jq 'length')
  
  if [[ "$ready_ungrouped_count" != "0" ]]; then
    echo -e "${GREEN}Ready to execute:${RESET}"
    echo "$ready_ungrouped" | jq -r '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢"
       end) as $badge |
      "  \($badge) [\(.priority)] \(.title) (\(.id))"
    '
    echo ""
  fi
  
  # Grouped tasks under objectives/parents
  # Find all tasks that have children (are parents)
  local parent_ids
  parent_ids=$(echo "$resolved_tasks" | jq -r '[.[].parent_id | select(. != null and . != "")] | unique | .[]' 2>/dev/null || true)
  
  if [[ -n "$parent_ids" ]]; then
    echo -e "${MAGENTA}Grouped under objectives:${RESET}"
    
    # For each parent, show its hierarchy
    while IFS= read -r parent_id; do
      [[ -z "$parent_id" ]] && continue
      
      # Get parent task info
      local parent_info
      parent_info=$(echo "$resolved_tasks" | jq --arg pid "$parent_id" '.[] | select(.id == $pid)')
      
      if [[ -n "$parent_info" ]] && [[ "$parent_info" != "null" ]]; then
        local parent_title parent_status
        parent_title=$(echo "$parent_info" | jq -r '.title')
        parent_status=$(echo "$parent_info" | jq -r '.status')
        
        # Display parent with icon based on status
        local parent_icon="üìã"
        case "$parent_status" in
          active|in_progress) parent_icon="üîÑ" ;;
          completed) parent_icon="‚úÖ" ;;
          blocked) parent_icon="üö´" ;;
        esac
        
        echo -e "  ${parent_icon} ${BOLD}${parent_title}${RESET} (${parent_id})"
        
        # Get all children of this parent
        local children
        children=$(echo "$resolved_tasks" | jq --arg pid "$parent_id" '[.[] | select(.parent_id == $pid)]')
        
        # Display children with proper indentation
        echo "$children" | jq -r --argjson all "$resolved_tasks" '.[] |
          (if .priority == "high" then "üî¥"
           elif .priority == "medium" then "üü°"
           else "üü¢"
           end) as $badge |
          (if .classification == "ready" then "‚úì ready"
           elif .classification == "waiting" then "‚è≥ waiting"
           elif .classification == "waiting_on_parent" then "‚è≥ waiting on parent"
           elif .classification == "blocked" then "‚õî blocked"
           elif .classification == "blocked_by_parent" then "‚õî blocked by parent"
           elif .status == "in_progress" then "üîÑ in progress"
           elif .status == "completed" then "‚úÖ done"
           else .status
           end) as $status_str |
          "    \($badge) [\(.priority)] \(.title) (\(.id))",
          (if .classification == "waiting" then
            (.waiting_on[] as $dep_id |
              ($all | .[] | select(.id == $dep_id)) as $dep |
              "       ‚îî‚îÄ waiting on: \($dep.title) (\($dep.status))"
            )
           elif .classification == "blocked" then
            (.blocked_by[] as $dep_id |
              ($all | .[] | select(.id == $dep_id)) as $dep |
              "       ‚îî‚îÄ blocked by: \($dep.title) (\($dep.status // $dep.classification))"
            )
           else empty
           end)
        '
        
        # Check for grandchildren (recursive hierarchy)
        local child_ids
        child_ids=$(echo "$children" | jq -r '.[].id')
        while IFS= read -r child_id; do
          [[ -z "$child_id" ]] && continue
          local grandchildren
          grandchildren=$(echo "$resolved_tasks" | jq --arg cid "$child_id" '[.[] | select(.parent_id == $cid)]')
          local gc_count
          gc_count=$(echo "$grandchildren" | jq 'length')
          if [[ "$gc_count" != "0" ]]; then
            echo "$grandchildren" | jq -r --argjson all "$resolved_tasks" '.[] |
              (if .priority == "high" then "üî¥"
               elif .priority == "medium" then "üü°"
               else "üü¢"
               end) as $badge |
              "      ‚îî‚îÄ \($badge) \(.title) (\(.id))",
              (if .classification == "waiting" then
                (.waiting_on[] as $dep_id |
                  ($all | .[] | select(.id == $dep_id)) as $dep |
                  "         ‚îî‚îÄ waiting on: \($dep.title) (\($dep.status))"
                )
               else empty
               end)
            '
          fi
        done <<< "$child_ids"
        
        echo ""
      fi
    done <<< "$parent_ids"
  fi
  
  # Ungrouped waiting tasks (no parent)
  local waiting_ungrouped
  waiting_ungrouped=$(echo "$resolved_tasks" | jq '[.[] | select((.classification == "waiting" or .classification == "waiting_on_parent") and (.parent_id == null or .parent_id == ""))]')
  local waiting_ungrouped_count
  waiting_ungrouped_count=$(echo "$waiting_ungrouped" | jq 'length')
  
  if [[ "$waiting_ungrouped_count" != "0" ]]; then
    echo -e "${YELLOW}Ungrouped - Waiting on dependencies:${RESET}"
    echo "$waiting_ungrouped" | jq -r --argjson all "$resolved_tasks" '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢"
       end) as $badge |
      "  \($badge) [\(.priority)] \(.title) (\(.id))",
      (.waiting_on[] as $dep_id |
        ($all | .[] | select(.id == $dep_id)) as $dep |
        "     ‚îî‚îÄ waiting on: \($dep.title) (\($dep.status))"
      )
    '
    echo ""
  fi
  
  # Ungrouped blocked tasks (no parent)
  local blocked_ungrouped
  blocked_ungrouped=$(echo "$resolved_tasks" | jq '[.[] | select((.classification == "blocked" or .classification == "blocked_by_parent") and (.parent_id == null or .parent_id == ""))]')
  local blocked_ungrouped_count
  blocked_ungrouped_count=$(echo "$blocked_ungrouped" | jq 'length')
  
  if [[ "$blocked_ungrouped_count" != "0" ]]; then
    echo -e "${RED}Ungrouped - Blocked:${RESET}"
    echo "$blocked_ungrouped" | jq -r --argjson all "$resolved_tasks" '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢"
       end) as $badge |
      "  \($badge) [\(.priority)] \(.title) (\(.id))",
      (.blocked_by[] as $dep_id |
        ($all | .[] | select(.id == $dep_id)) as $dep |
        "     ‚îî‚îÄ blocked by: \($dep.title) (\($dep.status // $dep.classification))"
      )
    '
    echo ""
  fi
  
  # Circular dependency tasks
  local circular
  circular=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "circular")]')
  local circular_count
  circular_count=$(echo "$circular" | jq 'length')
  
  if [[ "$circular_count" != "0" ]]; then
    echo -e "${RED}${BOLD}‚ö†Ô∏è  Circular Dependencies (ERROR):${RESET}"
    echo "$circular" | jq -r --argjson all "$resolved_tasks" '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢"
       end) as $badge |
      "  \($badge) [\(.priority)] \(.title) (\(.id))",
      (.resolved_deps[] as $dep_id |
        ($all | .[] | select(.id == $dep_id)) as $dep |
        if $dep.in_cycle then
          "     ‚îî‚îÄ ‚ü≥ depends on: \($dep.title) (circular)"
        else
          "     ‚îî‚îÄ depends on: \($dep.title) (\($dep.status))"
        end
      )
    '
    echo ""
    echo -e "${DIM}  These tasks cannot be executed until the cycle is broken.${RESET}"
    echo -e "${DIM}  Remove one dependency to break the cycle.${RESET}"
    echo ""
  fi
  
  # In Progress tasks (ungrouped)
  local in_progress
  in_progress=$(echo "$resolved_tasks" | jq '[.[] | select(.status == "in_progress" and (.parent_id == null or .parent_id == ""))]')
  local in_progress_count
  in_progress_count=$(echo "$in_progress" | jq 'length')
  
  if [[ "$in_progress_count" != "0" ]]; then
    echo -e "${BLUE}In Progress:${RESET}"
    echo "$in_progress" | jq -r '.[] | "  üîÑ \(.title) (\(.id))"'
    echo ""
  fi
  
  # Completed tasks (recent, ungrouped)
  local completed
  completed=$(echo "$resolved_tasks" | jq '[.[] | select(.status == "completed" and (.parent_id == null or .parent_id == ""))] | sort_by(.created) | reverse | .[0:5]')
  local completed_count
  completed_count=$(echo "$resolved_tasks" | jq '[.[] | select(.status == "completed")] | length')
  
  if [[ "$completed_count" != "0" ]]; then
    echo -e "${DIM}Completed (recent):${RESET}"
    echo "$completed" | jq -r '.[] | "  ‚úì \(.title) (\(.id))"'
    local ungrouped_completed
    ungrouped_completed=$(echo "$resolved_tasks" | jq '[.[] | select(.status == "completed" and (.parent_id == null or .parent_id == ""))] | length')
    if [[ "$ungrouped_completed" -gt 5 ]]; then
      echo "  ... and $((ungrouped_completed - 5)) more"
    fi
    echo ""
  fi
  
  # Calculate summary counts
  local ready_count waiting_count blocked_count
  ready_count=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "ready")] | length')
  waiting_count=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "waiting" or .classification == "waiting_on_parent")] | length')
  blocked_count=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "blocked" or .classification == "blocked_by_parent")] | length')
  local all_in_progress_count
  all_in_progress_count=$(echo "$resolved_tasks" | jq '[.[] | select(.status == "in_progress")] | length')
  local grouped_count
  grouped_count=$(echo "$resolved_tasks" | jq '[.[] | select(.parent_id != null and .parent_id != "")] | length')
  
  # Summary
  echo -e "${BOLD}Summary:${RESET}"
  echo "  Ready: $ready_count"
  echo "  Waiting: $waiting_count"
  echo "  Blocked: $blocked_count"
  echo "  Circular: $circular_count"
  echo "  In Progress: $all_in_progress_count"
  echo "  Completed: $completed_count"
  if [[ "$grouped_count" -gt 0 ]]; then
    echo "  Grouped under parents: $grouped_count"
  fi
}

# =============================================================================
# Dashboard Window (tmux)
# =============================================================================

create_dashboard_window() {
  local window_name="$1"
  local workdir="$2"
  local runner_script="$3"
  
  # Create scripts for dashboard panes
  local task_list_script="${STATE_DIR}/task_list_${CURRENT_PROJECT_ID}.sh"
  local logs_script="${STATE_DIR}/logs_watch.sh"
  
  # Task list script with dependency info and hierarchy - refreshes every 10 seconds
  cat > "$task_list_script" << TASKLIST_EOF
#!/bin/bash
PROJECT_ID="$CURRENT_PROJECT_ID"
BRAIN_DIR="$BRAIN_DIR"
SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_NAME"

show_tasks_for_project() {
  local proj="\$1"
  local indent="\${2:-}"
  
  # Fetch all resolved tasks for this project
  local all_tasks
  all_tasks=\$("\$SCRIPT_PATH" list "\$proj" --json 2>/dev/null || echo "[]")
  
  # Ready tasks
  local ready
  ready=\$("\$SCRIPT_PATH" ready "\$proj" --json 2>/dev/null || echo "[]")
  local ready_count
  ready_count=\$(echo "\$ready" | jq 'length' 2>/dev/null || echo "0")
  if [[ "\$ready_count" != "0" ]]; then
    echo -e "\${indent}\033[32m‚úì Ready (\$ready_count):\033[0m"
    echo "\$ready" | jq -r --arg ind "\$indent" '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢" end) as \$b |
      "\(\$ind)  \(\$b) \(.title)"' 2>/dev/null
  fi
  
  # In Progress tasks
  local in_progress_count
  in_progress_count=\$(echo "\$all_tasks" | jq '[.[] | select(.status == "in_progress")] | length' 2>/dev/null || echo "0")
  if [[ "\$in_progress_count" != "0" ]]; then
    echo -e "\${indent}\033[34müîÑ In Progress (\$in_progress_count):\033[0m"
    echo "\$all_tasks" | jq -r --arg ind "\$indent" '[.[] | select(.status == "in_progress")] | .[] |
      "\(\$ind)  ‚Ä¢ \(.title)"' 2>/dev/null
  fi
  
  # Waiting tasks
  local waiting
  waiting=\$("\$SCRIPT_PATH" waiting "\$proj" --json 2>/dev/null || echo "[]")
  local waiting_count
  waiting_count=\$(echo "\$waiting" | jq 'length' 2>/dev/null || echo "0")
  if [[ "\$waiting_count" != "0" ]]; then
    echo -e "\${indent}\033[33m‚è≥ Waiting (\$waiting_count):\033[0m"
    echo "\$waiting" | jq -r --arg ind "\$indent" '.[0:3] | .[] |
      "\(\$ind)  ‚Ä¢ \(.title)"' 2>/dev/null
    if [[ "\$waiting_count" -gt 3 ]]; then
      echo "\${indent}  ... and \$((\$waiting_count - 3)) more"
    fi
  fi
  
  # Blocked tasks
  local blocked
  blocked=\$("\$SCRIPT_PATH" blocked "\$proj" --json 2>/dev/null || echo "[]")
  local blocked_count
  blocked_count=\$(echo "\$blocked" | jq 'length' 2>/dev/null || echo "0")
  if [[ "\$blocked_count" != "0" ]]; then
    echo -e "\${indent}\033[31müö´ Blocked (\$blocked_count):\033[0m"
    echo "\$blocked" | jq -r --arg ind "\$indent" '.[0:2] | .[] |
      "\(\$ind)  üö´ \(.title)"' 2>/dev/null
  fi
}

show_tasks() {
  clear
  
  if [[ "\$PROJECT_ID" == "all" ]]; then
    # Multi-project mode
    echo -e "\033[1m‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\033[0m"
    echo -e "\033[1m‚îÇ   üìã Tasks: All Projects              ‚îÇ\033[0m"
    echo -e "\033[1m‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\033[0m"
    echo ""
    
    # Loop through discovered projects
    for proj in \$("\$SCRIPT_PATH" projects 2>/dev/null); do
      [[ -z "\$proj" ]] && continue
      local task_count
      task_count=\$("\$SCRIPT_PATH" list "\$proj" --json 2>/dev/null | jq '[.[] | select(.status == "pending" or .status == "in_progress")] | length' 2>/dev/null || echo "0")
      
      # Only show projects with active tasks
      if [[ "\$task_count" != "0" ]]; then
        echo -e "\033[35müìÅ \$proj\033[0m (\$task_count active)"
        show_tasks_for_project "\$proj" "  "
        echo ""
      fi
    done
  else
    # Single project mode (original behavior)
    local display_id="\${PROJECT_ID:0:12}"
    [[ \${#PROJECT_ID} -gt 12 ]] && display_id="\${display_id}..."
    
    echo -e "\033[1m‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\033[0m"
    printf "\033[1m‚îÇ   üìã Tasks (hierarchy): %-13s ‚îÇ\033[0m\n" "\$display_id"
    echo -e "\033[1m‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\033[0m"
    echo ""
    
    # Use do-work-deps to get dependency-aware task lists
    if [[ -x "\$SCRIPT_PATH" ]]; then
      # Fetch all resolved tasks once (includes dependency and parent info)
      local all_tasks
      all_tasks=\$("\$SCRIPT_PATH" list "\$PROJECT_ID" --json 2>/dev/null || echo "[]")
      
      # Check if there are grouped tasks (with parent_id)
      local has_grouped
      has_grouped=\$(echo "\$all_tasks" | jq '[.[] | select(.parent_id != null and .parent_id != "")] | length' 2>/dev/null || echo "0")
      
      # Ready tasks (ungrouped) - with priority badges
      echo -e "\033[32m‚úì Ready:\033[0m"
      local ready
      ready=\$("\$SCRIPT_PATH" ready "\$PROJECT_ID" --json 2>/dev/null || echo "[]")
      local ready_list
      ready_list=\$(echo "\$ready" | jq -r '.[] | select(.parent_id == null or .parent_id == "") |
        (if .priority == "high" then "üî¥"
         elif .priority == "medium" then "üü°"
         else "üü¢" end) as \$badge |
        "  \(\$badge) \(.title)"' 2>/dev/null)
      if [[ -n "\$ready_list" ]]; then
        echo "\$ready_list"
      else
        echo "  (none)"
      fi
      
      # Show grouped tasks under objectives if any
      if [[ "\$has_grouped" != "0" ]]; then
        echo ""
        echo -e "\033[35müìÅ Grouped under objectives:\033[0m"
        
        # Get unique parent IDs
        local parent_ids
        parent_ids=\$(echo "\$all_tasks" | jq -r '[.[].parent_id | select(. != null and . != "")] | unique | .[]' 2>/dev/null)
        
        while IFS= read -r parent_id; do
          [[ -z "\$parent_id" ]] && continue
          
          # Get parent info
          local parent_title parent_status
          parent_title=\$(echo "\$all_tasks" | jq -r --arg pid "\$parent_id" '.[] | select(.id == \$pid) | .title // "Unknown"' 2>/dev/null)
          parent_status=\$(echo "\$all_tasks" | jq -r --arg pid "\$parent_id" '.[] | select(.id == \$pid) | .status // "pending"' 2>/dev/null)
          
          # Choose parent icon
          local parent_icon="üìã"
          case "\$parent_status" in
            active|in_progress) parent_icon="üîÑ" ;;
            completed) parent_icon="‚úÖ" ;;
            blocked) parent_icon="üö´" ;;
          esac
          
          echo "  \$parent_icon \$parent_title"
          
          # Get children of this parent
          local children
          children=\$(echo "\$all_tasks" | jq -r --arg pid "\$parent_id" '
            [.[] | select(.parent_id == \$pid)] | .[] |
            (if .priority == "high" then "üî¥"
             elif .priority == "medium" then "üü°"
             else "üü¢" end) as \$badge |
            (if .classification == "ready" then "‚úì"
             elif .classification == "waiting" or .classification == "waiting_on_parent" then "‚è≥"
             elif .classification == "blocked" or .classification == "blocked_by_parent" then "‚õî"
             elif .status == "in_progress" then "üîÑ"
             elif .status == "completed" then "‚úÖ"
             else "" end) as \$status |
            "    ‚îî‚îÄ \(\$badge) \(.title) \(\$status)"
          ' 2>/dev/null)
          if [[ -n "\$children" ]]; then
            echo "\$children"
          fi
        done <<< "\$parent_ids"
      fi
      
      echo ""
      echo -e "\033[34müîÑ In Progress:\033[0m"
      local in_progress
      in_progress=\$(echo "\$all_tasks" | jq -r --argjson all "\$all_tasks" '
        # Print task with parent info if it has one
        [.[] | select(.status == "in_progress")] | .[] |
        (if .parent_id and .parent_id != "" then
          (\$all | .[] | select(.id == .parent_id) | .title) as \$parent_title |
          "  ‚Ä¢ \(.title) [under: \(\$parent_title // "?")]"
         else
          "  ‚Ä¢ \(.title)"
         end)
      ' 2>/dev/null)
      if [[ -n "\$in_progress" ]]; then
        echo "\$in_progress"
      else
        echo "  (none)"
      fi
    
    echo ""
    echo -e "\033[33m‚è≥ Waiting:\033[0m"
    local waiting
    waiting=\$("\$SCRIPT_PATH" waiting "\$PROJECT_ID" --json 2>/dev/null || echo "[]")
    local waiting_list
    waiting_list=\$(echo "\$waiting" | jq -r --argjson all "\$all_tasks" '
      .[] | select(.parent_id == null or .parent_id == "") |
      "  ‚Ä¢ \(.title)",
      ((.waiting_on // [])[] as \$dep_id |
        (\$all | .[] | select(.id == \$dep_id)) as \$dep |
        if \$dep then "    ‚îî‚îÄ waiting on: \(\$dep.title) (\(\$dep.status))" else empty end
      )
    ' 2>/dev/null)
    # Also show tasks waiting on parent
    local waiting_parent
    waiting_parent=\$(echo "\$all_tasks" | jq -r '
      [.[] | select(.classification == "waiting_on_parent")] | .[] |
      "  ‚Ä¢ \(.title) (waiting on parent)"
    ' 2>/dev/null)
    if [[ -n "\$waiting_list" ]] || [[ -n "\$waiting_parent" ]]; then
      [[ -n "\$waiting_list" ]] && echo "\$waiting_list"
      [[ -n "\$waiting_parent" ]] && echo "\$waiting_parent"
    else
      echo "  (none)"
    fi
    
    echo ""
    echo -e "\033[31müö´ Blocked:\033[0m"
    local blocked
    blocked=\$("\$SCRIPT_PATH" blocked "\$PROJECT_ID" --json 2>/dev/null || echo "[]")
    local blocked_list
    blocked_list=\$(echo "\$blocked" | jq -r --argjson all "\$all_tasks" '
      .[] |
      (if .classification == "blocked_by_parent" then
        "  üö´ \(.title) (blocked by parent)"
       else
        "  üö´ \(.title)",
        ((.blocked_by // [])[] as \$dep_id |
          (\$all | .[] | select(.id == \$dep_id)) as \$dep |
          if \$dep then "    ‚îî‚îÄ blocked by: \(\$dep.title) (\(\$dep.status // \$dep.classification))" else empty end
        )
       end)
    ' 2>/dev/null)
    if [[ -n "\$blocked_list" ]]; then
      echo "\$blocked_list"
    else
      echo "  (none)"
    fi
    
    echo ""
    echo -e "\033[32m‚úÖ Completed (recent):\033[0m"
    local completed
    completed=\$(echo "\$all_tasks" | jq -r '[.[] | select(.status == "completed")] | sort_by(.created) | reverse | .[0:3] | .[] | "  ‚úì \(.title)"' 2>/dev/null)
    if [[ -n "\$completed" ]]; then
      echo "\$completed"
    else
      echo "  (none)"
    fi
    else
      echo "  Script not found: \$SCRIPT_PATH"
    fi
  fi
  
  echo ""
  echo -e "\033[2m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\033[0m"
  echo -e "\033[2mRefreshes every 10s | \$(date +%H:%M:%S)\033[0m"
}

while true; do
  show_tasks
  sleep 10
done
TASKLIST_EOF
  chmod +x "$task_list_script"
  
  # Logs watch script
  cat > "$logs_script" << 'LOGS_EOF'
#!/bin/bash
LOG_FILE="${HOME}/.local/log/do-work-deps.log"
echo -e "\033[1müìú do-work-deps logs\033[0m"
echo -e "\033[2m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\033[0m"
tail -f "$LOG_FILE" 2>/dev/null | while read -r line; do
  if [[ "$line" == *"[ERROR]"* ]]; then
    echo -e "\033[31m$line\033[0m"
  elif [[ "$line" == *"[WARN]"* ]]; then
    echo -e "\033[33m$line\033[0m"
  elif [[ "$line" == *"[INFO]"* ]]; then
    echo -e "\033[32m$line\033[0m"
  elif [[ "$line" == *"[DEBUG]"* ]]; then
    echo -e "\033[2m$line\033[0m"
  else
    echo "$line"
  fi
done
LOGS_EOF
  chmod +x "$logs_script"
  
  # Create window with task list pane
  tmux new-window -d -n "$window_name" -c "$workdir" "$task_list_script"
  sleep 0.3
  
  # Split horizontally for main area (75% right)
  local opencode_pane_id
  opencode_pane_id=$(tmux split-window -t "${window_name}.0" -h -d -P -F '#{pane_id}' -l 75% "$runner_script")
  sleep 0.2
  
  # Split the main area vertically for logs (20% bottom)
  tmux split-window -t "$opencode_pane_id" -v -d -l 20% "$logs_script"
  
  # Set pane titles
  local tasks_pane_id
  tasks_pane_id=$(tmux list-panes -t "$window_name" -F '#{pane_index} #{pane_id}' | grep "^0 " | awk '{print $2}')
  local logs_pane_id
  logs_pane_id=$(tmux list-panes -t "$window_name" -F '#{pane_index} #{pane_id}' | grep "^2 " | awk '{print $2}')
  
  tmux select-pane -t "$tasks_pane_id" -T "Tasks"
  tmux select-pane -t "$opencode_pane_id" -T "OpenCode"
  tmux select-pane -t "$logs_pane_id" -T "Logs"
  
  # Save pane IDs
  echo "$tasks_pane_id" > "${STATE_DIR}/dashboard_tasks_pane_${CURRENT_PROJECT_ID}"
  echo "$opencode_pane_id" > "${STATE_DIR}/dashboard_opencode_pane_${CURRENT_PROJECT_ID}"
  echo "$logs_pane_id" > "${STATE_DIR}/dashboard_logs_pane_${CURRENT_PROJECT_ID}"
}

# =============================================================================
# OpenCode Integration (Parallel Execution Support)
# =============================================================================

# Spawn OpenCode for a task (supports parallel execution)
# Arguments: task_id, task_path, task_title, [is_resume], [task_workdir], [task_worktree], [task_git_remote], [task_git_branch]
# Returns: JSON with pid and pane_id
spawn_opencode_async() {
  local task_id="$1"
  local task_path="$2"
  local task_title="$3"
  local is_resume="${4:-false}"
  local task_workdir="${5:-}"
  local task_worktree="${6:-}"
  local task_git_remote="${7:-}"
  local task_git_branch="${8:-}"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    local mode_str="process"
    [[ "$is_resume" == "true" ]] && mode_str="RESUME"
    log INFO "[DRY-RUN] Would spawn OpenCode to $mode_str: $task_title"
    log INFO "[DRY-RUN] Task path: $task_path"
    # Return fake result for dry run
    echo '{"pid": 0, "pane_id": ""}'
    return 0
  fi
  
  if [[ "$is_resume" == "true" ]]; then
    log INFO "Spawning OpenCode to RESUME: $task_title (id: $task_id)"
  else
    log INFO "Spawning OpenCode to process: $task_title (id: $task_id)"
  fi
  
  # Build the prompt
  local prompt
  if [[ "$is_resume" == "true" ]]; then
    prompt="Load the do-work-queue skill and RESUME the interrupted task at brain path: ${task_path}

IMPORTANT: This task was previously in_progress but was interrupted.

Use brain_recall to read the task details, then:
1. Check the task file for any progress notes or partial work
2. Assess what work (if any) was already completed
3. If work was partially done, continue from where it left off
4. If unclear what was done, restart the task from the beginning
5. Follow the do-work-queue skill workflow to completion
6. Mark as completed with summary (note that this was a resumed task)
7. Create atomic git commit

Start now."
  else
    prompt="Load the do-work-queue skill and process the task at brain path: ${task_path}

Use brain_recall to read the task details, then follow the do-work-queue skill workflow:
1. Mark the task as in_progress
2. Triage complexity (Route A/B/C)
3. Execute the appropriate route
4. Run tests if applicable
5. Mark as completed with summary
6. Create atomic git commit

Start now."
  fi

  # Use task-specific prompt file for parallel execution
  local prompt_file="${STATE_DIR}/prompt_${CURRENT_PROJECT_ID}_${task_id}.txt"
  echo "$prompt" > "$prompt_file"
  
  # Resolve workdir: task-specific workdir > global WORK_DIR > $HOME
  local workdir
  if [[ -n "$task_workdir" ]] || [[ -n "$task_worktree" ]] || [[ -n "$task_git_remote" ]]; then
    workdir=$(resolve_workdir "$task_workdir" "$task_worktree" "$task_git_remote")
    log INFO "Resolved task workdir: $workdir"
    [[ -n "$task_git_branch" ]] && log INFO "Branch context: $task_git_branch"
  else
    # Default to $HOME to ensure global OpenCode config is used (not local .opencode/)
    workdir="${WORK_DIR:-$HOME}"
  fi
  
  if [[ "$BACKGROUND" == "true" ]]; then
    # Background mode: completely detached, no pane visibility
    log DEBUG "Starting OpenCode run in background (model: $MODEL)"
    
    local output_file="${STATE_DIR}/output_${CURRENT_PROJECT_ID}_${task_id}.log"
    
    (cd "$workdir" && "$OPENCODE_BIN" run --agent "$AGENT" --model "$MODEL" "$(cat "$prompt_file")" > "$output_file" 2>&1) &
    local pid=$!
    
    # Track spawned PID for cleanup
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    echo "{\"pid\": ${pid}, \"pane_id\": \"\"}"
    
  elif [[ "$USE_TUI" == "true" ]]; then
    # TUI mode: interactive opencode TUI in pane (requires manual close)
    log DEBUG "Starting OpenCode TUI in tmux pane (model: $MODEL)"
    
    local window_name="do-work-deps_${CURRENT_PROJECT_ID}"
    local pane_id
    
    # Truncate title for pane display (max 20 chars)
    local short_title="${task_title:0:20}"
    [[ ${#task_title} -gt 20 ]] && short_title="${short_title}..."
    
    # Write a task-specific runner script for TUI mode
    local runner_script="${STATE_DIR}/runner_${CURRENT_PROJECT_ID}_${task_id}.sh"
    cat > "$runner_script" << RUNNER_EOF
#!/bin/bash
cd "$workdir"
"$OPENCODE_BIN" --agent "$AGENT" --model "$MODEL" --port 0 --prompt "\$(cat '$prompt_file')"
exit_code=\$?
echo ""
if [[ \$exit_code -eq 0 ]]; then
  echo "Task completed. Pane closing in 3s..."
  sleep 3
else
  echo "Exit code: \$exit_code. Press Enter to close."
  read
fi
exit 0
RUNNER_EOF
    chmod +x "$runner_script"
    
    # Create pane for this task
    pane_id=$(create_task_pane "$task_id" "$short_title" "$runner_script")
    
    if [[ -z "$pane_id" ]]; then
      log ERROR "Failed to create pane for task: $task_title"
      echo '{"pid": 0, "pane_id": ""}'
      return 1
    fi
    
    # Wait for OpenCode to start
    sleep 2
    
    # Get the PID of the OpenCode process
    local bash_pid
    bash_pid=$(tmux list-panes -t "$window_name" -F '#{pane_id} #{pane_pid}' 2>/dev/null | grep "^${pane_id} " | awk '{print $2}' | head -1)
    local pid
    pid=$(pgrep -P "$bash_pid" -f opencode 2>/dev/null | head -1 || echo "$bash_pid")
    
    # Track spawned PID for cleanup
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    echo "{\"pid\": ${pid}, \"pane_id\": \"${pane_id}\"}"
    
  else
    # Default mode: opencode run in visible tmux pane (auto-exits on completion)
    log DEBUG "Starting OpenCode run in tmux pane (model: $MODEL)"
    
    local window_name="do-work-deps_${CURRENT_PROJECT_ID}"
    local pane_id
    
    # Truncate title for pane display (max 20 chars)
    local short_title="${task_title:0:20}"
    [[ ${#task_title} -gt 20 ]] && short_title="${short_title}..."
    
    # Write a task-specific runner script using 'opencode run'
    local runner_script="${STATE_DIR}/runner_${CURRENT_PROJECT_ID}_${task_id}.sh"
    cat > "$runner_script" << RUNNER_EOF
#!/bin/bash
cd "$workdir"
"$OPENCODE_BIN" run --agent "$AGENT" --model "$MODEL" "\$(cat '$prompt_file')"
exit_code=\$?
echo ""
if [[ \$exit_code -eq 0 ]]; then
  echo "Task completed. Pane closing in 3s..."
  sleep 3
else
  echo "Exit code: \$exit_code. Press Enter to close."
  read
fi
exit 0
RUNNER_EOF
    chmod +x "$runner_script"
    
    # Create pane for this task
    pane_id=$(create_task_pane "$task_id" "$short_title" "$runner_script")
    
    if [[ -z "$pane_id" ]]; then
      log ERROR "Failed to create pane for task: $task_title"
      echo '{"pid": 0, "pane_id": ""}'
      return 1
    fi
    
    # Wait for OpenCode to start
    sleep 2
    
    # Get the PID of the OpenCode process
    local bash_pid
    bash_pid=$(tmux list-panes -t "$window_name" -F '#{pane_id} #{pane_pid}' 2>/dev/null | grep "^${pane_id} " | awk '{print $2}' | head -1)
    local pid
    pid=$(pgrep -P "$bash_pid" -f opencode 2>/dev/null | head -1 || echo "$bash_pid")
    
    # Track spawned PID for cleanup
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    echo "{\"pid\": ${pid}, \"pane_id\": \"${pane_id}\"}"
  fi
}

# Create a tmux pane for a task (horizontal split for parallel execution)
# Returns: pane_id
create_task_pane() {
  local task_id="$1"
  local task_title="$2"
  local runner_script="$3"
  
  local window_name="do-work-deps_${CURRENT_PROJECT_ID}"
  local pane_id
  
  # Ensure window exists
  if ! tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${window_name}$"; then
    log ERROR "Dashboard window not found: $window_name"
    return 1
  fi
  
  # Find existing task panes (titled "Task:*")
  local task_panes
  task_panes=$(tmux list-panes -t "$window_name" -F '#{pane_id} #{pane_title}' 2>/dev/null | grep "Task:" | awk '{print $1}')
  local task_pane_count
  task_pane_count=$(echo "$task_panes" | grep -c '%' || echo "0")
  
  # Find the logs pane (we'll split above it)
  local logs_pane
  logs_pane=$(tmux list-panes -t "$window_name" -F '#{pane_id} #{pane_title}' 2>/dev/null | grep "Logs" | awk '{print $1}' | head -1)
  
  # Find the Tasks sidebar pane
  local tasks_pane
  tasks_pane=$(tmux list-panes -t "$window_name" -F '#{pane_id} #{pane_title}' 2>/dev/null | grep "Tasks" | awk '{print $1}' | head -1)
  
  if [[ "$task_pane_count" -eq 0 ]]; then
    # First task - create pane above logs (or beside Tasks if no logs)
    if [[ -n "$logs_pane" ]]; then
      # Split above logs pane, take 80% of the space
      pane_id=$(tmux split-window -t "$logs_pane" -v -d -P -F '#{pane_id}' -b -l 80% "$runner_script")
    elif [[ -n "$tasks_pane" ]]; then
      # Split horizontally from tasks pane
      pane_id=$(tmux split-window -t "$tasks_pane" -h -d -P -F '#{pane_id}' -l 75% "$runner_script")
    else
      log ERROR "Cannot find anchor pane for task creation"
      return 1
    fi
  else
    # Additional task - split the last task pane horizontally
    local last_task_pane
    last_task_pane=$(echo "$task_panes" | tail -1)
    
    if [[ -n "$last_task_pane" ]]; then
      # Split horizontally (side by side)
      pane_id=$(tmux split-window -t "$last_task_pane" -h -d -P -F '#{pane_id}' "$runner_script")
    else
      log ERROR "Cannot find task pane to split"
      return 1
    fi
  fi
  
  if [[ -n "$pane_id" ]]; then
    # Set pane title
    tmux select-pane -t "$pane_id" -T "Task:${task_title}"
    sleep 0.2
  fi
  
  echo "$pane_id"
}

# Legacy wrapper for backward compatibility (sequential mode)
spawn_opencode() {
  local task_path="$1"
  local task_title="$2"
  local is_resume="${3:-false}"
  local task_workdir="${4:-}"
  local task_worktree="${5:-}"
  local task_git_remote="${6:-}"
  local task_git_branch="${7:-}"
  
  # Extract task_id from path
  local task_id
  task_id=$(basename "$task_path" .md)
  
  # Call async version and extract just the pid
  local result
  result=$(spawn_opencode_async "$task_id" "$task_path" "$task_title" "$is_resume" "$task_workdir" "$task_worktree" "$task_git_remote" "$task_git_branch")
  
  # Return just the pid for backward compatibility
  echo "$result" | jq -r '.pid'
}

# Spawn OpenCode in a standalone tmux window (for run-one without dashboard)
# Arguments: task_id, task_path, task_title, [is_resume], [task_workdir], [task_worktree], [task_git_remote], [task_git_branch]
# Returns: JSON with pid and window_name
spawn_opencode_standalone() {
  local task_id="$1"
  local task_path="$2"
  local task_title="$3"
  local is_resume="${4:-false}"
  local task_workdir="${5:-}"
  local task_worktree="${6:-}"
  local task_git_remote="${7:-}"
  local task_git_branch="${8:-}"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    local mode_str="process"
    [[ "$is_resume" == "true" ]] && mode_str="RESUME"
    log INFO "[DRY-RUN] Would spawn OpenCode to $mode_str: $task_title"
    log INFO "[DRY-RUN] Task path: $task_path"
    echo '{"pid": 0, "window_name": ""}'
    return 0
  fi
  
  if [[ "$is_resume" == "true" ]]; then
    log INFO "Spawning OpenCode to RESUME: $task_title (id: $task_id)"
  else
    log INFO "Spawning OpenCode to process: $task_title (id: $task_id)"
  fi
  
  # Build the prompt
  local prompt
  if [[ "$is_resume" == "true" ]]; then
    prompt="Load the do-work-queue skill and RESUME the interrupted task at brain path: ${task_path}

IMPORTANT: This task was previously in_progress but was interrupted.

Use brain_recall to read the task details, then:
1. Check the task file for any progress notes or partial work
2. Assess what work (if any) was already completed
3. If work was partially done, continue from where it left off
4. If unclear what was done, restart the task from the beginning
5. Follow the do-work-queue skill workflow to completion
6. Mark as completed with summary (note that this was a resumed task)
7. Create atomic git commit

Start now."
  else
    prompt="Load the do-work-queue skill and process the task at brain path: ${task_path}

Use brain_recall to read the task details, then follow the do-work-queue skill workflow:
1. Mark the task as in_progress
2. Triage complexity (Route A/B/C)
3. Execute the appropriate route
4. Run tests if applicable
5. Mark as completed with summary
6. Create atomic git commit

Start now."
  fi

  local prompt_file="${STATE_DIR}/prompt_${CURRENT_PROJECT_ID}_${task_id}.txt"
  echo "$prompt" > "$prompt_file"
  
  # Resolve workdir: task-specific workdir > global WORK_DIR > $HOME
  local workdir
  if [[ -n "$task_workdir" ]] || [[ -n "$task_worktree" ]] || [[ -n "$task_git_remote" ]]; then
    workdir=$(resolve_workdir "$task_workdir" "$task_worktree" "$task_git_remote")
    log INFO "Resolved task workdir: $workdir"
    [[ -n "$task_git_branch" ]] && log INFO "Branch context: $task_git_branch"
  else
    workdir="${WORK_DIR:-$HOME}"
  fi
  
  if [[ "$BACKGROUND" == "true" ]]; then
    # Background mode: completely detached, no window visibility
    log DEBUG "Starting OpenCode run in background (model: $MODEL)"
    
    local output_file="${STATE_DIR}/output_${CURRENT_PROJECT_ID}_${task_id}.log"
    
    (cd "$workdir" && "$OPENCODE_BIN" run --agent "$AGENT" --model "$MODEL" "$(cat "$prompt_file")" > "$output_file" 2>&1) &
    local pid=$!
    
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    echo "{\"pid\": ${pid}, \"window_name\": \"\"}"
    
  elif [[ "$USE_TUI" == "true" ]]; then
    # TUI mode: interactive opencode TUI in standalone window (requires manual close)
    log DEBUG "Starting OpenCode TUI in standalone tmux window (model: $MODEL)"
    
    # Create a unique window name
    local window_name="task_${task_id}"
    
    # Truncate title for window name (max 20 chars)
    local short_title="${task_title:0:20}"
    [[ ${#task_title} -gt 20 ]] && short_title="${short_title}..."
    
    # Write a task-specific runner script for TUI mode
    local runner_script="${STATE_DIR}/runner_${CURRENT_PROJECT_ID}_${task_id}.sh"
    cat > "$runner_script" << RUNNER_EOF
#!/bin/bash
cd "$workdir"
"$OPENCODE_BIN" --agent "$AGENT" --model "$MODEL" --port 0 --prompt "\$(cat '$prompt_file')"
exit_code=\$?
echo ""
if [[ \$exit_code -eq 0 ]]; then
  echo "Task completed. Window closing in 3s..."
  sleep 3
else
  echo "Exit code: \$exit_code. Press Enter to close."
  read
fi
exit 0
RUNNER_EOF
    chmod +x "$runner_script"
    
    # Create a new tmux window in the background
    tmux new-window -d -n "$window_name" -c "$workdir" "$runner_script"
    
    # Wait for window to be created and process to start
    sleep 2
    
    # Get the PID of the process in the window
    local pane_pid
    pane_pid=$(tmux list-panes -t "$window_name" -F '#{pane_pid}' 2>/dev/null | head -1)
    local pid
    pid=$(pgrep -P "$pane_pid" -f opencode 2>/dev/null | head -1 || echo "$pane_pid")
    
    # Track spawned PID for cleanup
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    # Store window name for cleanup
    echo "$window_name" > "${STATE_DIR}/standalone_window_${CURRENT_PROJECT_ID}_${task_id}"
    
    log INFO "Created tmux window: $window_name (switch with: tmux select-window -t $window_name)"
    
    echo "{\"pid\": ${pid}, \"window_name\": \"${window_name}\"}"
    
  else
    # Default mode: opencode run in visible tmux window (auto-exits on completion)
    log DEBUG "Starting OpenCode run in standalone tmux window (model: $MODEL)"
    
    # Create a unique window name
    local window_name="task_${task_id}"
    
    # Truncate title for window name (max 20 chars)
    local short_title="${task_title:0:20}"
    [[ ${#task_title} -gt 20 ]] && short_title="${short_title}..."
    
    # Write a task-specific runner script using 'opencode run'
    local runner_script="${STATE_DIR}/runner_${CURRENT_PROJECT_ID}_${task_id}.sh"
    cat > "$runner_script" << RUNNER_EOF
#!/bin/bash
cd "$workdir"
"$OPENCODE_BIN" run --agent "$AGENT" --model "$MODEL" "\$(cat '$prompt_file')"
exit_code=\$?
echo ""
if [[ \$exit_code -eq 0 ]]; then
  echo "Task completed. Window closing in 3s..."
  sleep 3
else
  echo "Exit code: \$exit_code. Press Enter to close."
  read
fi
exit 0
RUNNER_EOF
    chmod +x "$runner_script"
    
    # Create a new tmux window in the background
    tmux new-window -d -n "$window_name" -c "$workdir" "$runner_script"
    
    # Wait for window to be created and process to start
    sleep 2
    
    # Get the PID of the process in the window
    local pane_pid
    pane_pid=$(tmux list-panes -t "$window_name" -F '#{pane_pid}' 2>/dev/null | head -1)
    local pid
    pid=$(pgrep -P "$pane_pid" -f opencode 2>/dev/null | head -1 || echo "$pane_pid")
    
    # Track spawned PID for cleanup
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$CURRENT_PROJECT_ID")
    echo "$pid" >> "$spawned_pids_file"
    
    # Store window name for cleanup
    echo "$window_name" > "${STATE_DIR}/standalone_window_${CURRENT_PROJECT_ID}_${task_id}"
    
    log INFO "Created tmux window: $window_name (switch with: tmux select-window -t $window_name)"
    
    echo "{\"pid\": ${pid}, \"window_name\": \"${window_name}\"}"
  fi
}

wait_for_opencode() {
  local pid="$1"
  local task_path="$2"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log INFO "[DRY-RUN] Task completed (simulated)"
    return 0
  fi
  
  log INFO "Waiting for OpenCode (PID: $pid) to complete..."
  
  if [[ "$BACKGROUND" == "true" ]]; then
    # Background mode: process is a direct child, use wait
    if wait "$pid" 2>/dev/null; then
      log INFO "OpenCode completed successfully"
      return 0
    else
      local exit_code=$?
      log WARN "OpenCode exited with code: $exit_code"
      return $exit_code
    fi
  else
    # Pane-based mode (default or TUI): poll for completion
    # Process runs in tmux pane, so we poll task file status and check process
    local max_wait=1800  # 30 minutes max
    local waited=0
    local poll_interval=10
    
    while [[ $waited -lt $max_wait ]]; do
      sleep $poll_interval
      waited=$((waited + poll_interval))
      
      local current_status
      current_status=$(grep -E "^status:" "$task_path" 2>/dev/null | awk '{print $2}' || echo "unknown")
      
      if [[ "$current_status" == "completed" ]]; then
        log INFO "Task completed successfully (detected from brain)"
        local pane_id
        pane_id=$(cat "${STATE_DIR}/current_pane_id_${CURRENT_PROJECT_ID}" 2>/dev/null) || true
        if [[ -n "$pane_id" ]]; then
          log INFO "Closing tmux pane $pane_id"
          (tmux kill-pane -t "$pane_id" 2>/dev/null) || true
          rm -f "${STATE_DIR}/current_pane_id_${CURRENT_PROJECT_ID}" 2>/dev/null || true
        fi
        return 0
      elif [[ "$current_status" == "blocked" ]] || [[ "$current_status" == "failed" ]]; then
        log WARN "Task ended with status: $current_status"
        return 1
      fi
      
      if ! kill -0 "$pid" 2>/dev/null; then
        # Process exited - check final status
        current_status=$(grep -E "^status:" "$task_path" 2>/dev/null | awk '{print $2}' || echo "unknown")
        if [[ "$current_status" == "completed" ]]; then
          log INFO "Task completed successfully (process exited)"
          return 0
        else
          log WARN "OpenCode process exited (final status: $current_status)"
          return 1
        fi
      fi
      
      debug "Task still in progress (waited ${waited}s)..."
    done
    
    log WARN "Timeout waiting for task completion"
    # Kill the timed-out process
    if kill -0 "$pid" 2>/dev/null; then
      log WARN "Killing timed-out OpenCode process (PID: $pid)"
      kill -TERM "$pid" 2>/dev/null || true
      sleep 2
      kill -9 "$pid" 2>/dev/null || true
    fi
    return 1
  fi
}

check_opencode_running() {
  local pid="$1"
  
  if [[ -z "$pid" ]] || [[ "$pid" == "null" ]]; then
    return 1
  fi
  
  if kill -0 "$pid" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

# Non-blocking check for task completion (for parallel execution)
# Returns: "running", "completed", "failed", "blocked", "timeout", "crashed"
check_task_completion() {
  local task_id="$1"
  
  local pid="${RUNNING_TASKS_PID[$task_id]:-}"
  local task_path="${RUNNING_TASKS_PATH[$task_id]:-}"
  local started_at="${RUNNING_TASKS_STARTED[$task_id]:-}"
  
  if [[ -z "$pid" ]] || [[ -z "$task_path" ]]; then
    echo "crashed"
    return
  fi
  
  # Check task status from the brain file
  local full_path="${BRAIN_DIR}/${task_path}"
  if [[ -f "$full_path" ]]; then
    local current_status
    current_status=$(grep -E "^status:" "$full_path" 2>/dev/null | awk '{print $2}' || echo "unknown")
    
    if [[ "$current_status" == "completed" ]]; then
      echo "completed"
      return
    elif [[ "$current_status" == "blocked" ]]; then
      echo "blocked"
      return
    elif [[ "$current_status" == "failed" ]]; then
      echo "failed"
      return
    fi
  fi
  
  # Check if process is still running
  if ! kill -0 "$pid" 2>/dev/null; then
    # Process exited but status wasn't updated - treat as crashed
    echo "crashed"
    return
  fi
  
  # Check for timeout (30 minutes max per task)
  local max_runtime=1800
  if [[ -n "$started_at" ]]; then
    local start_ts
    start_ts=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$started_at" "+%s" 2>/dev/null || echo "0")
    local now_ts
    now_ts=$(date "+%s")
    local elapsed=$((now_ts - start_ts))
    
    if [[ $elapsed -gt $max_runtime ]]; then
      echo "timeout"
      return
    fi
  fi
  
  echo "running"
}

# Kill a running task (cleanup after completion/failure/timeout)
cleanup_task() {
  local task_id="$1"
  local reason="${2:-unknown}"
  
  local pid="${RUNNING_TASKS_PID[$task_id]:-}"
  local pane_id="${RUNNING_TASKS_PANE[$task_id]:-}"
  local title="${RUNNING_TASKS_TITLE[$task_id]:-unknown}"
  
  log DEBUG "Cleaning up task: $title (reason: $reason)"
  
  # Kill process if still running
  if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
    log WARN "Terminating OpenCode process for task $title (PID: $pid)"
    kill -TERM "$pid" 2>/dev/null || true
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
      kill -9 "$pid" 2>/dev/null || true
    fi
  fi
  
  # Close tmux pane if exists
  if [[ -n "$pane_id" ]] && [[ "$USE_TUI" == "true" ]]; then
    log DEBUG "Closing pane $pane_id for task $title"
    tmux kill-pane -t "$pane_id" 2>/dev/null || true
  fi
  
  # Remove from tracking
  remove_running_task "$task_id"
}

# =============================================================================
# Monitor Loop
# =============================================================================

run_monitor() {
  local project_id="$1"
  
  CURRENT_PROJECT_ID="$project_id"
  
  if [[ "$project_id" == "all" ]]; then
    local discovered_count
    discovered_count=$(discover_projects | wc -l | tr -d ' ')
    log INFO "Starting do-work-deps monitor for ALL PROJECTS (${discovered_count} discovered)"
    if [[ ${#EXCLUDE_PATTERNS[@]} -gt 0 ]]; then
      log INFO "Excluding patterns: ${EXCLUDE_PATTERNS[*]}"
    fi
  else
    log INFO "Starting do-work-deps monitor for project: $project_id"
  fi
  log INFO "Poll interval: ${POLL_INTERVAL}s"
  log INFO "Brain directory: $BRAIN_DIR"
  log INFO "Mode: $(if [[ "$USE_TUI" == "true" ]]; then echo "TUI"; else echo "run (non-TUI)"; fi)"
  log INFO "Dependency resolution: ENABLED"
  
  MONITOR_STARTED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  COMPLETED_COUNT=0
  FAILED_COUNT=0
  
  save_state "$project_id" "running"
  
  trap 'shutdown_monitor' SIGTERM SIGINT
  
  # Create dashboard window in TUI mode
  if [[ "$USE_TUI" == "true" ]]; then
    local window_name="do-work-deps_${project_id}"
    DASHBOARD_WINDOW_NAME="$window_name"  # Track for cleanup on exit
    if ! tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${window_name}$"; then
      log INFO "Creating dashboard window: $window_name"
      local workdir="${WORK_DIR:-$(pwd)}"
      local placeholder_script="${STATE_DIR}/waiting_placeholder_${project_id}.sh"
      cat > "$placeholder_script" << 'PLACEHOLDER_EOF'
#!/bin/bash
echo ""
echo "  ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     ‚è≥ Parallel Task Execution          ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     Monitor is polling for READY        ‚îÇ"
echo "  ‚îÇ     tasks (dependencies resolved).      ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     Task panes will appear here         ‚îÇ"
echo "  ‚îÇ     when tasks are picked up.           ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     Multiple tasks run in parallel!     ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"
echo ""
while true; do sleep 3600; done
PLACEHOLDER_EOF
      chmod +x "$placeholder_script"
      create_dashboard_window "$window_name" "$workdir" "$placeholder_script"
      log INFO "Dashboard window created. Switch to it with: tmux select-window -t $window_name"
    fi
  fi
  
  # =========================================================================
  # Startup Recovery: Resume interrupted tasks
  # =========================================================================
  log INFO "Checking for interrupted tasks..."
  
  local interrupted_json
  interrupted_json=$(query_interrupted_tasks "$project_id")
  
  if [[ -n "$interrupted_json" ]] && [[ "$interrupted_json" != "null" ]]; then
    local interrupted_count
    interrupted_count=$(echo "$interrupted_json" | grep -c '^{' || echo "0")
    
    if [[ "$interrupted_count" -gt 0 ]]; then
      log WARN "Found $interrupted_count interrupted task(s), will resume before processing new tasks"
      
      while IFS= read -r task_json; do
        [[ -z "$task_json" ]] && continue
        [[ "$task_json" == "null" ]] && continue
        
        local task_path task_relative_path task_title task_priority task_resume_count
        task_path=$(echo "$task_json" | jq -r '.path')
        task_relative_path=$(echo "$task_json" | jq -r '.relative_path')
        task_title=$(echo "$task_json" | jq -r '.title')
        task_priority=$(echo "$task_json" | jq -r '.priority')
        task_resume_count=$(echo "$task_json" | jq -r '.resume_count // 0')
        
        if [[ ! -f "$task_path" ]]; then
          log WARN "Interrupted task file not found, skipping: $task_path"
          continue
        fi
        
        if check_task_interrupted "$task_relative_path" "$project_id"; then
          local max_resumes=3
          if [[ "$task_resume_count" -ge "$max_resumes" ]]; then
            log ERROR "Task has been resumed $task_resume_count times (max: $max_resumes), marking as blocked: $task_title"
            sed -i '' "s/^status:.*/status: blocked/" "$task_path"
            local block_note="# BLOCKED: Exceeded maximum resume attempts ($max_resumes). Manual intervention required."
            if ! grep -q "BLOCKED: Exceeded maximum resume" "$task_path" 2>/dev/null; then
              echo "" >> "$task_path"
              echo "$block_note" >> "$task_path"
            fi
            ((FAILED_COUNT+=1)) || true
            continue
          fi
          
          log INFO "Resuming interrupted task: $task_title (attempt $((task_resume_count + 1)))"
          
          increment_resume_count "$task_relative_path"
          
          local task_started
          task_started=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          local opencode_pid
          opencode_pid=$(spawn_opencode "$task_relative_path" "$task_title" "true")
          
          save_state "$project_id" "resuming" "$task_relative_path" "$task_title" "$task_priority" "$task_started" "$opencode_pid"
          
          if wait_for_opencode "$opencode_pid" "$task_path"; then
            log INFO "Resumed task completed: $task_title"
            ((COMPLETED_COUNT+=1)) || true
          else
            log WARN "Resumed task failed: $task_title"
            ((FAILED_COUNT+=1)) || true
          fi
          
          # Ensure OpenCode process is dead after task ends (success or failure)
          if kill -0 "$opencode_pid" 2>/dev/null; then
            log WARN "OpenCode process still running after resumed task ended, killing..."
            kill -TERM "$opencode_pid" 2>/dev/null || true
            sleep 1
            kill -9 "$opencode_pid" 2>/dev/null || true
          fi
          
          save_state "$project_id" "running"
          sleep 2
        else
          debug "Task $task_title has active process, skipping resume"
        fi
      done <<< "$interrupted_json"
      
      log INFO "Finished processing interrupted tasks"
    else
      log INFO "No interrupted tasks found"
    fi
  else
    log INFO "No interrupted tasks found"
  fi
  
  # =========================================================================
  # Main Loop: Process ready tasks in PARALLEL (dependency-aware)
  # =========================================================================
  log INFO "Parallel execution: max $MAX_PARALLEL concurrent tasks"
  log INFO "Task poll interval: ${TASK_POLL_INTERVAL}s"
  
  while true; do
    # -----------------------------------------------------------------------
    # Step 1: Check all running tasks for completion
    # -----------------------------------------------------------------------
    local running_count
    running_count=$(get_running_task_count)
    
    if [[ $running_count -gt 0 ]]; then
      debug "Checking $running_count running task(s)..."
      
      for task_id in $(get_running_task_ids); do
        local status
        status=$(check_task_completion "$task_id")
        local title="${RUNNING_TASKS_TITLE[$task_id]:-unknown}"
        
        case "$status" in
          completed)
            log INFO "Task completed: $title (id: $task_id)"
            cleanup_task "$task_id" "completed"
            ((COMPLETED_COUNT+=1)) || true
            
            # Log newly ready tasks after completion
            local newly_ready
            newly_ready=$(get_ready_tasks "$project_id")
            local newly_ready_count
            newly_ready_count=$(echo "$newly_ready" | jq 'length')
            if [[ "$newly_ready_count" -gt 0 ]]; then
              log INFO "Dependency resolution: $newly_ready_count task(s) now ready"
            fi
            ;;
          failed|blocked)
            log WARN "Task $status: $title (id: $task_id)"
            cleanup_task "$task_id" "$status"
            ((FAILED_COUNT+=1)) || true
            ;;
          timeout)
            log ERROR "Task timed out: $title (id: $task_id)"
            cleanup_task "$task_id" "timeout"
            ((FAILED_COUNT+=1)) || true
            ;;
          crashed)
            log ERROR "Task crashed (process exited unexpectedly): $title (id: $task_id)"
            cleanup_task "$task_id" "crashed"
            ((FAILED_COUNT+=1)) || true
            ;;
          running)
            # Task still running, do nothing
            ;;
        esac
      done
    fi
    
    # -----------------------------------------------------------------------
    # Step 2: Calculate available slots and spawn new tasks
    # -----------------------------------------------------------------------
    running_count=$(get_running_task_count)
    local available_slots=$((MAX_PARALLEL - running_count))
    
    if [[ $available_slots -gt 0 ]]; then
      # Get all ready tasks
      local ready_tasks
      ready_tasks=$(get_ready_tasks "$project_id")
      
      # Filter out tasks already running
      local filtered_ready="[]"
      if [[ -n "$ready_tasks" ]] && [[ "$ready_tasks" != "null" ]]; then
        filtered_ready=$(echo "$ready_tasks" | jq -c --argjson running "$(printf '%s\n' "${!RUNNING_TASKS_PID[@]}" | jq -R . | jq -s .)" '
          [.[] | select(.id as $id | $running | index($id) | not)]
        ')
      fi
      
      local ready_count
      ready_count=$(echo "$filtered_ready" | jq 'length')
      
      if [[ "$ready_count" -gt 0 ]]; then
        # Determine how many tasks to spawn
        local spawn_count=$available_slots
        [[ $ready_count -lt $spawn_count ]] && spawn_count=$ready_count
        
        log INFO "Spawning $spawn_count new task(s) (slots: $available_slots, ready: $ready_count)"
        
        # Spawn tasks up to available slots
        for ((i=0; i<spawn_count; i++)); do
          local task
          task=$(echo "$filtered_ready" | jq -r ".[$i]")
          
          local task_id task_path task_relative_path task_title task_priority task_project
          local task_workdir task_worktree task_git_remote task_git_branch
          task_id=$(echo "$task" | jq -r '.id')
          task_path=$(echo "$task" | jq -r '.path')
          task_relative_path=$(echo "$task" | jq -r '.relative_path')
          task_title=$(echo "$task" | jq -r '.title')
          task_priority=$(echo "$task" | jq -r '.priority')
          # Extract project from task (for "all" mode, tasks have .project field)
          task_project=$(echo "$task" | jq -r '.project // "'"$project_id"'"')
          # Extract workdir fields
          task_workdir=$(echo "$task" | jq -r '.workdir // empty')
          task_worktree=$(echo "$task" | jq -r '.worktree // empty')
          task_git_remote=$(echo "$task" | jq -r '.git_remote // empty')
          task_git_branch=$(echo "$task" | jq -r '.git_branch // empty')
          
          if [[ -z "$task_path" ]] || [[ "$task_path" == "null" ]] || [[ ! -f "$task_path" ]]; then
            log WARN "Task file not found: $task_path, skipping"
            continue
          fi
          
          if [[ "$project_id" == "all" ]]; then
            log INFO "Starting task: $task_title (priority: $task_priority, id: $task_id, project: $task_project)"
          else
            log INFO "Starting task: $task_title (priority: $task_priority, id: $task_id)"
          fi
          
          # Spawn OpenCode asynchronously with resolved workdir
          local spawn_result
          spawn_result=$(spawn_opencode_async "$task_id" "$task_relative_path" "$task_title" "false" "$task_workdir" "$task_worktree" "$task_git_remote" "$task_git_branch")
          
          local pid pane_id
          pid=$(echo "$spawn_result" | jq -r '.pid')
          pane_id=$(echo "$spawn_result" | jq -r '.pane_id // ""')
          
          if [[ "$pid" == "0" ]] || [[ -z "$pid" ]]; then
            log ERROR "Failed to spawn OpenCode for task: $task_title"
            continue
          fi
          
          # Track the running task (with project for multi-project mode)
          add_running_task "$task_id" "$task_relative_path" "$task_title" "$pid" "$pane_id" "$task_project"
        done
      fi
    fi
    
    # -----------------------------------------------------------------------
    # Step 3: Update state and sleep
    # -----------------------------------------------------------------------
    running_count=$(get_running_task_count)
    
    if [[ $running_count -gt 0 ]]; then
      save_state "$project_id" "processing"
    else
      save_state "$project_id" "idle"
    fi
    
    # Short sleep to check task completion frequently
    sleep "$TASK_POLL_INTERVAL" &
    wait $! 2>/dev/null || true
  done
}

shutdown_monitor() {
  log INFO "Shutting down do-work-deps monitor..."
  
  local project_id="${CURRENT_PROJECT_ID:-}"
  
  if [[ -n "$project_id" ]]; then
    # Clean up all running tasks (parallel execution tracking)
    local running_count
    running_count=$(get_running_task_count)
    if [[ $running_count -gt 0 ]]; then
      log INFO "Cleaning up $running_count running task(s)..."
      for task_id in $(get_running_task_ids); do
        cleanup_task "$task_id" "shutdown"
      done
    fi
    
    # Also kill any spawned PIDs from the tracking file (belt and suspenders)
    local spawned_pids_file
    spawned_pids_file=$(get_spawned_pids_file "$project_id")
    if [[ -f "$spawned_pids_file" ]]; then
      log DEBUG "Cleaning up spawned PID file..."
      while IFS= read -r spawned_pid; do
        if [[ -n "$spawned_pid" ]] && kill -0 "$spawned_pid" 2>/dev/null; then
          log WARN "Terminating remaining spawned process (PID: $spawned_pid)"
          kill -TERM "$spawned_pid" 2>/dev/null || true
        fi
      done < "$spawned_pids_file"
      sleep 1
      # Force kill any remaining
      while IFS= read -r spawned_pid; do
        if [[ -n "$spawned_pid" ]] && kill -0 "$spawned_pid" 2>/dev/null; then
          log WARN "Force killing process (PID: $spawned_pid)"
          kill -9 "$spawned_pid" 2>/dev/null || true
        fi
      done < "$spawned_pids_file"
      rm -f "$spawned_pids_file"
    fi
    
    # Clear running tasks state
    clear_running_tasks
    
    save_state "$project_id" "stopped"
    
    local pid_file
    pid_file=$(get_pid_file "$project_id")
    rm -f "$pid_file"
  fi
  
  # Close dashboard window if we created it (foreground mode only)
  if [[ "$FOREGROUND" == "true" ]] && [[ -n "$DASHBOARD_WINDOW_NAME" ]]; then
    if tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${DASHBOARD_WINDOW_NAME}$"; then
      log INFO "Closing dashboard window: $DASHBOARD_WINDOW_NAME"
      tmux kill-window -t "$DASHBOARD_WINDOW_NAME" 2>/dev/null || true
    fi
  fi
  
  log INFO "Monitor stopped"
  exit 0
}

# =============================================================================
# Commands
# =============================================================================

cmd_start() {
  local project_id=""
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --foreground|-f)
        FOREGROUND=true
        shift
        ;;
      --background|-b)
        FOREGROUND=false
        shift
        ;;
      --tui)
        USE_TUI=true
        shift
        ;;
      --no-tui)
        USE_TUI=false
        shift
        ;;
      --background-tasks)
        BACKGROUND=true
        USE_TUI=false  # Background tasks implies no TUI
        shift
        ;;
      --poll-interval)
        POLL_INTERVAL="$2"
        shift 2
        ;;
      --max-parallel|-p)
        MAX_PARALLEL="$2"
        shift 2
        ;;
      --task-poll-interval)
        TASK_POLL_INTERVAL="$2"
        shift 2
        ;;
      --workdir|-w)
        WORK_DIR="$2"
        shift 2
        ;;
      --agent)
        AGENT="$2"
        shift 2
        ;;
      --model|-m)
        MODEL="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --brain-dir)
        BRAIN_DIR="$2"
        shift 2
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      -*)
        die "Unknown option: $1"
        ;;
      *)
        if [[ -z "$project_id" ]]; then
          project_id="$1"
        else
          die "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  if [[ -z "$project_id" ]]; then
    project_id="$DEFAULT_PROJECT"
  fi
  
  if [[ -z "$WORK_DIR" ]]; then
    # Default to $HOME so OpenCode uses global config, not local .opencode/
    WORK_DIR="$HOME"
  fi
  
  # Check if already running
  local pid_file
  pid_file=$(get_pid_file "$project_id")
  if [[ -f "$pid_file" ]]; then
    local existing_pid
    existing_pid=$(cat "$pid_file")
    if kill -0 "$existing_pid" 2>/dev/null; then
      die "Monitor already running for project $project_id (PID: $existing_pid). Use '$SCRIPT_NAME stop $project_id' first."
    else
      rm -f "$pid_file"
    fi
  fi
  
  # Verify project has tasks directory (skip for "all" mode)
  if [[ "$project_id" != "all" ]]; then
    local project_dir="${BRAIN_DIR}/projects/${project_id}/task"
    if [[ ! -d "$project_dir" ]]; then
      log WARN "Task directory not found: $project_dir"
      log INFO "Creating task directory..."
      mkdir -p "$project_dir"
    fi
  fi
  
  echo -e "${GREEN}Starting do-work-deps monitor...${RESET}"
  if [[ "$project_id" == "all" ]]; then
    echo -e "  Project: ${CYAN}ALL PROJECTS${RESET}"
    if [[ ${#EXCLUDE_PATTERNS[@]} -gt 0 ]]; then
      echo -e "  Excluding: ${DIM}${EXCLUDE_PATTERNS[*]}${RESET}"
    fi
    # Show discovered projects count
    local discovered_count
    discovered_count=$(discover_projects | wc -l | tr -d ' ')
    echo -e "  Discovered: ${CYAN}${discovered_count}${RESET} projects"
  else
    echo -e "  Project: ${CYAN}${project_id}${RESET}"
  fi
  echo -e "  Brain: ${DIM}${BRAIN_DIR}${RESET}"
  echo -e "  Workdir: ${DIM}${WORK_DIR}${RESET}"
  echo -e "  Mode: $(if [[ "$USE_TUI" == "true" ]]; then echo "TUI"; else echo "run (silent)"; fi)"
  echo -e "  ${BOLD}Parallel:${RESET} max ${CYAN}${MAX_PARALLEL}${RESET} concurrent tasks"
  echo -e "  Task poll: ${DIM}${TASK_POLL_INTERVAL}s${RESET}"
  echo ""
  
  if [[ "$FOREGROUND" == "true" ]]; then
    echo "$$" > "$pid_file"
    run_monitor "$project_id"
  else
    echo -e "${GREEN}Starting in background...${RESET}"
    
    run_monitor "$project_id" &
    local daemon_pid=$!
    
    echo "$daemon_pid" > "$pid_file"
    echo -e "${GREEN}Monitor started (PID: $daemon_pid)${RESET}"
    echo -e "${DIM}Use '$SCRIPT_NAME status $project_id' to check status${RESET}"
    echo -e "${DIM}Use '$SCRIPT_NAME logs -f' to follow logs${RESET}"
  fi
}

cmd_stop() {
  local project_id="${1:-}"
  
  if [[ -z "$project_id" ]]; then
    local pid_files
    pid_files=$(ls "${RUN_DIR}"/do-work-deps-*.pid 2>/dev/null || true)
    
    if [[ -z "$pid_files" ]]; then
      echo -e "${YELLOW}No monitors running${RESET}"
      return 0
    fi
    
    local project_ids=()
    for pid_file in $pid_files; do
      local proj_id
      proj_id=$(basename "$pid_file" | sed 's/do-work-deps-//; s/.pid//')
      project_ids+=("$proj_id")
    done
    
    echo -e "${DIM}Found ${#project_ids[@]} monitors to stop${RESET}"
    
    for proj_id in "${project_ids[@]}"; do
      echo -e "${BLUE}Stopping monitor for project: $proj_id${RESET}"
      local pf
      pf=$(get_pid_file "$proj_id")
      if [[ -f "$pf" ]]; then
        local p
        p=$(cat "$pf")
        if kill -0 "$p" 2>/dev/null; then
          echo -e "${YELLOW}Stopping $proj_id (PID: $p)...${RESET}"
          kill -TERM "$p" 2>/dev/null || true
          sleep 2
          if kill -0 "$p" 2>/dev/null; then
            kill -9 "$p" 2>/dev/null || true
          fi
          rm -f "$pf"
          echo -e "${GREEN}Stopped $proj_id${RESET}"
        else
          rm -f "$pf"
        fi
      fi
    done
    return 0
  fi
  
  local pid_file
  pid_file=$(get_pid_file "$project_id")
  
  if [[ ! -f "$pid_file" ]]; then
    echo -e "${YELLOW}Monitor is not running for project: $project_id${RESET}"
    return 0
  fi
  
  local pid
  pid=$(cat "$pid_file")
  
  if kill -0 "$pid" 2>/dev/null; then
    echo -e "${YELLOW}Stopping monitor for $project_id (PID: $pid)...${RESET}"
    kill -TERM "$pid"
    
    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
      sleep 1
      ((count++))
    done
    
    if kill -0 "$pid" 2>/dev/null; then
      echo -e "${RED}Force killing monitor...${RESET}"
      kill -9 "$pid" 2>/dev/null || true
    fi
    
    rm -f "$pid_file"
    echo -e "${GREEN}Monitor stopped for $project_id${RESET}"
  else
    echo -e "${YELLOW}Monitor process not found, cleaning up...${RESET}"
    rm -f "$pid_file"
  fi
}

cmd_status() {
  local project_id="${1:-}"
  
  echo ""
  echo -e "${BOLD}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${RESET}"
  echo -e "${BOLD}‚îÇ               do-work-deps Monitor Status                        ‚îÇ${RESET}"
  echo -e "${BOLD}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${RESET}"
  echo ""
  
  if [[ -n "$project_id" ]]; then
    show_project_status "$project_id"
  else
    local state_files
    state_files=$(ls "${STATE_DIR}"/monitor-*.json 2>/dev/null || true)
    
    if [[ -z "$state_files" ]]; then
      echo -e "${DIM}No monitors have been started.${RESET}"
      echo ""
      return 0
    fi
    
    for state_file in $state_files; do
      local proj_id
      proj_id=$(basename "$state_file" | sed 's/monitor-//; s/.json//')
      echo -e "${BOLD}‚îÅ‚îÅ‚îÅ Project: ${CYAN}${proj_id}${RESET} ${BOLD}‚îÅ‚îÅ‚îÅ${RESET}"
      show_project_status "$proj_id"
      echo ""
    done
  fi
}

show_project_status() {
  local project_id="$1"
  local state_file pid_file
  state_file=$(get_state_file "$project_id")
  pid_file=$(get_pid_file "$project_id")
  
  local running=false
  local pid=""
  if [[ -f "$pid_file" ]]; then
    pid=$(cat "$pid_file")
    if kill -0 "$pid" 2>/dev/null; then
      running=true
    fi
  fi
  
  if [[ "$running" == "true" ]]; then
    echo -e "State: ${GREEN}${BOLD}RUNNING${RESET}"
  else
    echo -e "State: ${DIM}STOPPED${RESET}"
  fi
  
  if [[ -f "$state_file" ]]; then
    local state
    state=$(cat "$state_file")
    
    local started_at status workdir
    started_at=$(echo "$state" | jq -r '.started_at // "unknown"')
    status=$(echo "$state" | jq -r '.status // "unknown"')
    workdir=$(echo "$state" | jq -r '.workdir // "unknown"')
    
    echo -e "Project: ${CYAN}${project_id}${RESET}"
    echo -e "Started: ${started_at}"
    
    if [[ -n "$pid" ]]; then
      echo -e "PID: ${pid}"
    fi
    
    echo ""
    
    # Show running tasks (parallel execution)
    local running_tasks_file
    running_tasks_file=$(get_running_tasks_file "$project_id")
    if [[ -f "$running_tasks_file" ]]; then
      local running_tasks_json
      running_tasks_json=$(cat "$running_tasks_file")
      local running_task_count
      running_task_count=$(echo "$running_tasks_json" | jq 'length' 2>/dev/null || echo "0")
      
      if [[ "$running_task_count" -gt 0 ]]; then
        echo -e "${BOLD}Running Tasks (${BLUE}${running_task_count}${RESET}/${MAX_PARALLEL:-3}):${RESET}"
        echo "$running_tasks_json" | jq -r '.[] | 
          "  \u001b[34müîÑ\u001b[0m \(.title) (pid: \(.pid))"
        ' 2>/dev/null || true
        echo ""
      fi
    fi
    
    # Show dependency summary
    echo -e "${BOLD}Task Summary (with dependencies):${RESET}"
    local ready_count waiting_count blocked_count circular_count
    ready_count=$(get_ready_tasks "$project_id" 2>/dev/null | jq 'length' || echo "?")
    waiting_count=$(get_waiting_tasks "$project_id" 2>/dev/null | jq 'length' || echo "?")
    blocked_count=$(get_blocked_tasks "$project_id" 2>/dev/null | jq 'length' || echo "?")
    circular_count=$(get_circular_tasks "$project_id" 2>/dev/null | jq 'length' || echo "?")
    
    echo -e "  Ready: ${GREEN}${ready_count}${RESET}"
    echo -e "  Waiting: ${YELLOW}${waiting_count}${RESET}"
    echo -e "  Blocked: ${RED}${blocked_count}${RESET}"
    echo -e "  Circular: ${RED}${circular_count}${RESET}"
    
    # Stats
    local completed failed
    completed=$(echo "$state" | jq -r '.stats.completed // 0')
    failed=$(echo "$state" | jq -r '.stats.failed // 0')
    
    echo ""
    echo -e "${BOLD}Session Stats:${RESET}"
    echo -e "  Completed: ${GREEN}${completed}${RESET} tasks"
    echo -e "  Failed: ${RED}${failed}${RESET} tasks"
  else
    echo -e "${DIM}No state file found.${RESET}"
  fi
  
  echo ""
  echo -e "${DIM}Logs: ${LOG_FILE}${RESET}"
}

cmd_logs() {
  local follow=false
  local lines=50
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--follow)
        follow=true
        shift
        ;;
      -n)
        lines="$2"
        shift 2
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done
  
  if [[ ! -f "$LOG_FILE" ]]; then
    echo -e "${DIM}No log file found at: ${LOG_FILE}${RESET}"
    return 0
  fi
  
  if [[ "$follow" == "true" ]]; then
    echo -e "${DIM}Following logs (Ctrl+C to stop)...${RESET}"
    echo ""
    tail -f "$LOG_FILE"
  else
    tail -n "$lines" "$LOG_FILE"
  fi
}

cmd_list() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local json_output=false
  local show_hierarchy=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        json_output=true
        shift
        ;;
      --tree|--hierarchy)
        show_hierarchy=true
        shift
        ;;
      --all|-a)
        project_id="all"
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        project_id="$1"
        shift
        ;;
    esac
  done
  
  local tasks
  tasks=$(build_task_list "$project_id")
  
  local resolved
  resolved=$(resolve_dependencies "$tasks")
  
  local resolved_tasks
  resolved_tasks=$(get_resolved_tasks "$resolved")
  
  # JSON output mode - return all resolved tasks
  if [[ "$json_output" == "true" ]]; then
    echo "$resolved_tasks"
    return
  fi
  
  echo ""
  echo -e "${BOLD}All Tasks for Project: ${CYAN}${project_id}${RESET}"
  echo ""
  
  # Check if there are any hierarchical tasks
  local has_hierarchy
  has_hierarchy=$(echo "$resolved_tasks" | jq '[.[] | select(.parent_id != null and .parent_id != "")] | length')
  
  if [[ "$has_hierarchy" != "0" ]] || [[ "$show_hierarchy" == "true" ]]; then
    # Show hierarchical view
    echo -e "${DIM}(Showing hierarchical view - use --flat for flat view)${RESET}"
    echo ""
    
    # First show root tasks (no parent) organized by status
    local root_tasks
    root_tasks=$(echo "$resolved_tasks" | jq '[.[] | select(.parent_id == null or .parent_id == "")]')
    
    # Helper function to display task with children
    display_task_with_children() {
      local task_json="$1"
      local indent="$2"
      local all_tasks="$3"
      
      # This is complex in bash, so we'll use jq for the heavy lifting
      echo "$task_json" | jq -r --arg indent "$indent" --argjson all "$all_tasks" '
        . as $task |
        (if .priority == "high" then "üî¥"
         elif .priority == "medium" then "üü°"
         else "üü¢"
         end) as $badge |
        (if .status == "completed" then "‚úÖ"
         elif .status == "in_progress" then "üîÑ"
         elif .status == "blocked" then "üö´"
         elif .classification == "ready" then "‚úì"
         elif .classification == "waiting" or .classification == "waiting_on_parent" then "‚è≥"
         elif .classification == "blocked" or .classification == "blocked_by_parent" then "‚õî"
         elif .classification == "circular" then "‚ü≥"
         else ""
         end) as $status_icon |
        "\($indent)\($badge) \(.title) (\(.id)) \($status_icon)" +
        (if (.depends_on | length) > 0 then " [deps:\(.depends_on | length)]" else "" end)
      '
    }
    
    # Group root tasks by status
    for status in pending in_progress completed blocked; do
      local status_tasks
      if [[ "$status" == "pending" ]]; then
        status_tasks=$(echo "$root_tasks" | jq --arg s "$status" '[.[] | select(.status == $s and .classification != "circular")]')
      else
        status_tasks=$(echo "$root_tasks" | jq --arg s "$status" '[.[] | select(.status == $s)]')
      fi
      local count
      count=$(echo "$status_tasks" | jq 'length')
      
      if [[ "$count" != "0" ]]; then
        case "$status" in
          pending)     echo -e "${YELLOW}Pending:${RESET}" ;;
          in_progress) echo -e "${BLUE}In Progress:${RESET}" ;;
          completed)   echo -e "${GREEN}Completed:${RESET}" ;;
          blocked)     echo -e "${RED}Blocked:${RESET}" ;;
        esac
        
        # Display each root task and its children
        echo "$status_tasks" | jq -c '.[]' | while IFS= read -r task; do
          local task_id
          task_id=$(echo "$task" | jq -r '.id')
          
          # Display root task
          echo "$task" | jq -r --argjson all "$resolved_tasks" '
            . as $task |
            (if .priority == "high" then "üî¥"
             elif .priority == "medium" then "üü°"
             else "üü¢"
             end) as $badge |
            (if .classification == "ready" then " ‚úì"
             elif .classification == "waiting" or .classification == "waiting_on_parent" then " ‚è≥"
             elif .classification == "blocked" or .classification == "blocked_by_parent" then " ‚õî"
             else ""
             end) as $status_icon |
            "  \($badge) \(.title) (\(.id))\($status_icon)" +
            (if (.depends_on | length) > 0 then " [deps:\(.depends_on | length)]" else "" end)
          '
          
          # Get children of this task
          local children
          children=$(echo "$resolved_tasks" | jq --arg pid "$task_id" '[.[] | select(.parent_id == $pid)]')
          local child_count
          child_count=$(echo "$children" | jq 'length')
          
          if [[ "$child_count" != "0" ]]; then
            echo "$children" | jq -r --argjson all "$resolved_tasks" '.[] |
              (if .priority == "high" then "üî¥"
               elif .priority == "medium" then "üü°"
               else "üü¢"
               end) as $badge |
              (if .status == "completed" then "‚úÖ"
               elif .status == "in_progress" then "üîÑ"
               elif .classification == "ready" then "‚úì"
               elif .classification == "waiting" or .classification == "waiting_on_parent" then "‚è≥"
               elif .classification == "blocked" or .classification == "blocked_by_parent" then "‚õî"
               else ""
               end) as $status_icon |
              "    ‚îî‚îÄ \($badge) \(.title) (\(.id)) \($status_icon)"
            '
            
            # Check for grandchildren
            echo "$children" | jq -r '.[] | .id' | while IFS= read -r child_id; do
              local grandchildren
              grandchildren=$(echo "$resolved_tasks" | jq --arg cid "$child_id" '[.[] | select(.parent_id == $cid)]')
              local gc_count
              gc_count=$(echo "$grandchildren" | jq 'length')
              if [[ "$gc_count" != "0" ]]; then
                echo "$grandchildren" | jq -r '
                  .[] |
                  (if .priority == "high" then "üî¥"
                   elif .priority == "medium" then "üü°"
                   else "üü¢"
                   end) as $badge |
                  "       ‚îî‚îÄ \($badge) \(.title) (\(.id))"
                '
              fi
            done
          fi
        done
        echo ""
      fi
    done
    
    # Show circular tasks
    local circular_tasks
    circular_tasks=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "circular")]')
    local circular_count
    circular_count=$(echo "$circular_tasks" | jq 'length')
    
    if [[ "$circular_count" != "0" ]]; then
      echo -e "${RED}${BOLD}Circular Dependencies:${RESET}"
      echo "$circular_tasks" | jq -r '.[] |
        (if .priority == "high" then "üî¥"
         elif .priority == "medium" then "üü°"
         else "üü¢"
         end) as $badge |
        "  \($badge) \(.title) (\(.id)) ‚ü≥ [deps: \(.depends_on | length)]"
      '
      echo ""
    fi
    
  else
    # Flat view (original behavior for projects without hierarchy)
    for status in pending in_progress completed blocked; do
      local status_tasks
      if [[ "$status" == "pending" ]]; then
        status_tasks=$(echo "$resolved_tasks" | jq --arg s "$status" '[.[] | select(.status == $s and .classification != "circular")]')
      else
        status_tasks=$(echo "$resolved_tasks" | jq --arg s "$status" '[.[] | select(.status == $s)]')
      fi
      local count
      count=$(echo "$status_tasks" | jq 'length')
      
      if [[ "$count" != "0" ]]; then
        case "$status" in
          pending)     echo -e "${YELLOW}Pending:${RESET}" ;;
          in_progress) echo -e "${BLUE}In Progress:${RESET}" ;;
          completed)   echo -e "${GREEN}Completed:${RESET}" ;;
          blocked)     echo -e "${RED}Blocked:${RESET}" ;;
        esac
        
        echo "$status_tasks" | jq -r '.[] |
          (if .priority == "high" then "üî¥"
           elif .priority == "medium" then "üü°"
           else "üü¢"
           end) as $badge |
          "  \($badge) \(.title) (\(.id))" +
          (if (.depends_on | length) > 0 then " [deps: \(.depends_on | length)]" else "" end) +
          (if .classification == "blocked" or .classification == "blocked_by_parent" then " ‚õî"
           elif .classification == "waiting" or .classification == "waiting_on_parent" then " ‚è≥"
           elif .classification == "ready" then " ‚úì"
           else ""
           end)
        '
        echo ""
      fi
    done
    
    local circular_tasks
    circular_tasks=$(echo "$resolved_tasks" | jq '[.[] | select(.classification == "circular")]')
    local circular_count
    circular_count=$(echo "$circular_tasks" | jq 'length')
    
    if [[ "$circular_count" != "0" ]]; then
      echo -e "${RED}${BOLD}Circular Dependencies:${RESET}"
      echo "$circular_tasks" | jq -r '.[] |
        (if .priority == "high" then "üî¥"
         elif .priority == "medium" then "üü°"
         else "üü¢"
         end) as $badge |
        "  \($badge) \(.title) (\(.id)) ‚ü≥ [deps: \(.depends_on | length)]"
      '
      echo ""
    fi
  fi
}

cmd_ready() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local json_output=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        json_output=true
        shift
        ;;
      --all|-a)
        project_id="all"
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        project_id="$1"
        shift
        ;;
    esac
  done
  
  local ready
  ready=$(get_ready_tasks "$project_id")
  
  if [[ "$json_output" == "true" ]]; then
    echo "$ready"
  else
    echo ""
    display_tasks "$ready" "Ready to Execute"
    echo ""
  fi
}

cmd_waiting() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local json_output=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        json_output=true
        shift
        ;;
      --all|-a)
        project_id="all"
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        project_id="$1"
        shift
        ;;
    esac
  done
  
  local waiting
  waiting=$(get_waiting_tasks "$project_id")
  
  if [[ "$json_output" == "true" ]]; then
    echo "$waiting"
  else
    echo ""
    local count
    count=$(echo "$waiting" | jq 'length')
    
    if [[ "$count" == "0" ]]; then
      echo -e "${DIM}No tasks waiting on dependencies${RESET}"
      echo ""
      return
    fi
    
    echo -e "${BOLD}Waiting on Dependencies (${count}):${RESET}"
    echo ""
    
    local tasks
    tasks=$(build_task_list "$project_id")
    local resolved
    resolved=$(resolve_dependencies "$tasks")
    local resolved_tasks
    resolved_tasks=$(get_resolved_tasks "$resolved")
    
    echo "$waiting" | jq -r --argjson all "$resolved_tasks" '.[] |
      (if .priority == "high" then "üî¥"
       elif .priority == "medium" then "üü°"
       else "üü¢"
       end) as $badge |
      "  \($badge) [\(.priority)] \(.title) (\(.id))",
      (.waiting_on[] as $dep_id |
        ($all | .[] | select(.id == $dep_id)) as $dep |
        "     ‚îî‚îÄ waiting on: \($dep.title) (\($dep.status))"
      ),
      ""
    '
  fi
}

cmd_blocked() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  local json_output=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        json_output=true
        shift
        ;;
      --all|-a)
        project_id="all"
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        project_id="$1"
        shift
        ;;
    esac
  done
  
  local blocked
  blocked=$(get_blocked_tasks "$project_id")
  
  if [[ "$json_output" == "true" ]]; then
    echo "$blocked"
  else
    echo ""
    display_tasks "$blocked" "Blocked Tasks"
    echo ""
  fi
}

cmd_graph() {
  local project_id="${1:-$DEFAULT_PROJECT}"
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all|-a)
        project_id="all"
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        project_id="$1"
        shift
        ;;
    esac
  done
  
  if [[ "$project_id" == "all" ]]; then
    # Show graph for each project
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      display_graph "$proj"
      echo ""
      echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${RESET}"
      echo ""
    done < <(discover_projects)
  else
    display_graph "$project_id"
  fi
}

# =============================================================================
# Run-One Command: Execute single highest-priority task to completion
# =============================================================================

cmd_run_one() {
  local project_id=""
  local use_dashboard=false
  local skip_resume=false
  
  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --tui)
        USE_TUI=true
        shift
        ;;
      --no-tui)
        USE_TUI=false
        shift
        ;;
      --dashboard)
        use_dashboard=true
        shift
        ;;
      --workdir|-w)
        WORK_DIR="$2"
        shift 2
        ;;
      --agent)
        AGENT="$2"
        shift 2
        ;;
      --model|-m)
        MODEL="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --brain-dir)
        BRAIN_DIR="$2"
        shift 2
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      --all|-a)
        project_id="all"
        shift
        ;;
      --no-resume)
        skip_resume=true
        shift
        ;;
      --background)
        BACKGROUND=true
        USE_TUI=false  # Background implies no TUI
        shift
        ;;
      -*)
        die "Unknown option: $1"
        ;;
      *)
        if [[ -z "$project_id" ]]; then
          project_id="$1"
        else
          die "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  project_id="${project_id:-$DEFAULT_PROJECT}"
  CURRENT_PROJECT_ID="$project_id"
  WORK_DIR="${WORK_DIR:-$HOME}"
  
  # Helper function for priority badge
  priority_badge() {
    case "$1" in
      high)   echo -e "${RED}high${RESET}" ;;
      medium) echo -e "${YELLOW}medium${RESET}" ;;
      low)    echo -e "${GREEN}low${RESET}" ;;
      *)      echo "$1" ;;
    esac
  }
  
  # 1. Check for interrupted tasks first (unless --no-resume)
  local task_json=""
  local is_resume=false
  
  if [[ "$skip_resume" != "true" ]]; then
    local interrupted
    interrupted=$(query_interrupted_tasks "$project_id" | head -1)
    
    if [[ -n "$interrupted" ]] && [[ "$interrupted" != "null" ]]; then
      # Check if it's truly interrupted (no active process)
      local int_path
      int_path=$(echo "$interrupted" | jq -r '.relative_path')
      if check_task_interrupted "$int_path" "$project_id" 2>/dev/null; then
        task_json="$interrupted"
        is_resume=true
      fi
    fi
  fi
  
  # 2. If no interrupted task, get highest priority ready task
  if [[ -z "$task_json" ]] || [[ "$task_json" == "null" ]]; then
    task_json=$(get_next_ready_task "$project_id")
  fi
  
  # 3. Handle no tasks available
  if [[ -z "$task_json" ]] || [[ "$task_json" == "null" ]]; then
    echo -e "${YELLOW}No tasks ready to execute.${RESET}"
    # Show summary of why
    local waiting_count blocked_count
    waiting_count=$(get_waiting_tasks "$project_id" 2>/dev/null | jq 'length' || echo "0")
    blocked_count=$(get_blocked_tasks "$project_id" 2>/dev/null | jq 'length' || echo "0")
    [[ "$waiting_count" != "0" ]] && echo -e "  ${DIM}${waiting_count} task(s) waiting on dependencies${RESET}"
    [[ "$blocked_count" != "0" ]] && echo -e "  ${DIM}${blocked_count} task(s) blocked${RESET}"
    return 1
  fi
  
  # 4. Extract task info including workdir fields
  local task_id task_path task_relative_path task_title task_priority task_project
  local task_workdir task_worktree task_git_remote task_git_branch
  task_id=$(echo "$task_json" | jq -r '.id // (.path | split("/") | last | sub("\\.md$"; ""))')
  task_path=$(echo "$task_json" | jq -r '.path')
  task_relative_path=$(echo "$task_json" | jq -r '.relative_path')
  task_title=$(echo "$task_json" | jq -r '.title')
  task_priority=$(echo "$task_json" | jq -r '.priority // "medium"')
  task_project=$(echo "$task_json" | jq -r '.project // "'"$project_id"'"')
  # Extract workdir fields
  task_workdir=$(echo "$task_json" | jq -r '.workdir // empty')
  task_worktree=$(echo "$task_json" | jq -r '.worktree // empty')
  task_git_remote=$(echo "$task_json" | jq -r '.git_remote // empty')
  task_git_branch=$(echo "$task_json" | jq -r '.git_branch // empty')
  
  # Validate task file exists
  if [[ ! -f "$task_path" ]]; then
    echo -e "${RED}Task file not found: ${task_path}${RESET}"
    return 1
  fi
  
  # Resolve workdir for display and execution
  local resolved_workdir
  if [[ -n "$task_workdir" ]] || [[ -n "$task_worktree" ]] || [[ -n "$task_git_remote" ]]; then
    resolved_workdir=$(resolve_workdir "$task_workdir" "$task_worktree" "$task_git_remote")
  else
    resolved_workdir="${WORK_DIR:-$HOME}"
  fi
  
  # 5. Display what we're about to do
  echo ""
  echo -e "${BOLD}Running Single Task${RESET}"
  echo -e "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo -e "  Title: ${CYAN}${task_title}${RESET}"
  echo -e "  Priority: $(priority_badge "$task_priority")"
  [[ "$project_id" == "all" ]] && echo -e "  Project: ${CYAN}${task_project}${RESET}"
  echo -e "  Path: ${DIM}${task_relative_path}${RESET}"
  echo -e "  Workdir: ${DIM}${resolved_workdir}${RESET}"
  [[ -n "$task_git_branch" ]] && echo -e "  Branch: ${DIM}${task_git_branch}${RESET}"
  [[ "$is_resume" == "true" ]] && echo -e "  Mode: ${YELLOW}RESUMING interrupted task${RESET}"
  echo -e "  TUI: $(if [[ "$USE_TUI" == "true" ]]; then echo "enabled"; else echo "disabled"; fi)"
  echo ""
  
  if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${GREEN}[DRY-RUN] Would execute this task${RESET}"
    return 0
  fi
  
  # 6. Set up dashboard if requested
  if [[ "$use_dashboard" == "true" ]] && [[ "$USE_TUI" == "true" ]]; then
    local window_name="do-work-deps_${project_id}"
    DASHBOARD_WINDOW_NAME="$window_name"
    if ! tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${window_name}$"; then
      log INFO "Creating dashboard window: $window_name"
      local workdir="${WORK_DIR:-$(pwd)}"
      local placeholder_script="${STATE_DIR}/waiting_placeholder_${project_id}.sh"
      cat > "$placeholder_script" << 'PLACEHOLDER_EOF'
#!/bin/bash
echo ""
echo "  ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     ‚è≥ Single Task Execution            ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚îÇ     Running one task to completion.     ‚îÇ"
echo "  ‚îÇ                                         ‚îÇ"
echo "  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"
echo ""
while true; do sleep 3600; done
PLACEHOLDER_EOF
      chmod +x "$placeholder_script"
      create_dashboard_window "$window_name" "$workdir" "$placeholder_script"
      log INFO "Dashboard window created. Switch to it with: tmux select-window -t $window_name"
    fi
  fi
  
  # 7. Spawn OpenCode and wait
  local task_started
  task_started=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  if [[ "$is_resume" == "true" ]]; then
    local resume_count
    resume_count=$(echo "$task_json" | jq -r '.resume_count // 0')
    local max_resumes=3
    if [[ "$resume_count" -ge "$max_resumes" ]]; then
      echo -e "${RED}Task has been resumed $resume_count times (max: $max_resumes).${RESET}"
      echo -e "${RED}Manual intervention required.${RESET}"
      return 1
    fi
    increment_resume_count "$task_relative_path"
  fi
  
  log INFO "Starting task: $task_title (id: $task_id)"
  
  local opencode_pid
  local standalone_window=""
  
  if [[ "$use_dashboard" == "true" ]]; then
    # Use the dashboard-based spawning (requires dashboard window)
    # Note: spawn_opencode is a legacy wrapper, we need to use spawn_opencode_async for workdir support
    local spawn_result
    spawn_result=$(spawn_opencode_async "$task_id" "$task_relative_path" "$task_title" "$is_resume" "$task_workdir" "$task_worktree" "$task_git_remote" "$task_git_branch")
    opencode_pid=$(echo "$spawn_result" | jq -r '.pid')
  else
    # Use standalone window spawning
    local spawn_result
    spawn_result=$(spawn_opencode_standalone "$task_id" "$task_relative_path" "$task_title" "$is_resume" "$task_workdir" "$task_worktree" "$task_git_remote" "$task_git_branch")
    opencode_pid=$(echo "$spawn_result" | jq -r '.pid')
    standalone_window=$(echo "$spawn_result" | jq -r '.window_name // ""')
  fi
  
  if [[ -z "$opencode_pid" ]] || [[ "$opencode_pid" == "0" ]]; then
    echo -e "${RED}Failed to spawn OpenCode${RESET}"
    return 1
  fi
  
  # 8. Wait for completion
  local full_task_path="${BRAIN_DIR}/${task_relative_path}"
  if wait_for_opencode "$opencode_pid" "$full_task_path"; then
    echo ""
    echo -e "${GREEN}Task completed successfully!${RESET}"
    
    # Clean up windows
    if [[ "$use_dashboard" == "true" ]] && [[ -n "$DASHBOARD_WINDOW_NAME" ]]; then
      if tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${DASHBOARD_WINDOW_NAME}$"; then
        log INFO "Closing dashboard window: $DASHBOARD_WINDOW_NAME"
        tmux kill-window -t "$DASHBOARD_WINDOW_NAME" 2>/dev/null || true
      fi
    elif [[ -n "$standalone_window" ]] && [[ "$standalone_window" != "null" ]]; then
      # Standalone window cleans itself up after the script completes
      # But let's make sure it's gone
      if tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${standalone_window}$"; then
        log DEBUG "Standalone window $standalone_window will close automatically"
      fi
    fi
    
    return 0
  else
    echo ""
    echo -e "${RED}Task failed or was interrupted.${RESET}"
    
    # Ensure OpenCode process is dead
    if [[ -n "$opencode_pid" ]] && kill -0 "$opencode_pid" 2>/dev/null; then
      log WARN "Terminating OpenCode process..."
      kill -TERM "$opencode_pid" 2>/dev/null || true
      sleep 1
      kill -9 "$opencode_pid" 2>/dev/null || true
    fi
    
    # Clean up standalone window if it exists
    if [[ -n "$standalone_window" ]] && [[ "$standalone_window" != "null" ]]; then
      if tmux list-windows -F '#{window_name}' 2>/dev/null | grep -q "^${standalone_window}$"; then
        log INFO "Closing standalone window: $standalone_window"
        tmux kill-window -t "$standalone_window" 2>/dev/null || true
      fi
    fi
    
    return 1
  fi
}

cmd_projects() {
  local json_output=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        json_output=true
        shift
        ;;
      --exclude|-e)
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done
  
  if [[ "$json_output" == "true" ]]; then
    local projects=()
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      projects+=("\"$proj\"")
    done < <(discover_projects)
    # Output as JSON array
    local IFS=,
    echo "[${projects[*]}]"
  else
    echo ""
    echo -e "${BOLD}Discovered Projects:${RESET}"
    echo ""
    local count=0
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      local task_count
      task_count=$(query_all_tasks_single "$proj" 2>/dev/null | jq '[.[] | select(.status == "pending" or .status == "in_progress")] | length' || echo "?")
      local total_count
      total_count=$(query_all_tasks_single "$proj" 2>/dev/null | jq 'length' || echo "?")
      echo -e "  ${CYAN}${proj}${RESET} (${task_count} active / ${total_count} total)"
      ((count++))
    done < <(discover_projects)
    echo ""
    echo -e "${DIM}Total: ${count} projects${RESET}"
    if [[ ${#EXCLUDE_PATTERNS[@]} -gt 0 ]]; then
      echo -e "${DIM}Excluded patterns: ${EXCLUDE_PATTERNS[*]}${RESET}"
    fi
  fi
}

cmd_help() {
  echo -e "${BOLD}do-work-deps${RESET} - Parallel task processor with dependency support"
  echo ""
  echo -e "${BOLD}USAGE:${RESET}"
  echo "    $SCRIPT_NAME <command> [options]"
  echo ""
  echo -e "${BOLD}EXECUTION MODES:${RESET}"
  echo "    By default, tasks run via 'opencode run' in a visible tmux pane."
  echo "    The agent auto-completes and the pane closes when done."
  echo ""
  echo "    --tui             Use interactive TUI (requires manual close)"
  echo "    --background      Run completely in background (no pane, log to file)"
  echo ""
  echo -e "${BOLD}SINGLE-TASK EXECUTION:${RESET}"
  echo "    run-one <project-id>  Execute one highest-priority ready task"
  echo "        --all, -a         Pick from all projects"
  echo "        --tui             Use interactive TUI (requires manual close)"
  echo "        --background      Run in background (no pane, output to log file)"
  echo "        --dashboard       Create full dashboard window"
  echo "        --no-resume       Skip interrupted tasks, only run new ones"
  echo "        --workdir, -w     Working directory for OpenCode"
  echo "        --agent           Agent to use (default: general)"
  echo "        --model, -m       Model to use"
  echo "        --dry-run         Show what would run without executing"
  echo ""
  echo -e "${BOLD}MONITOR COMMANDS:${RESET}"
  echo "    start <project-id>    Start processing tasks (respects dependencies)"
  echo "        -b                Run monitor in background (daemon mode)"
  echo "        --foreground, -f  Run monitor in foreground (default)"
  echo "        --tui             Use interactive TUI for tasks (requires manual close)"
  echo "        --background-tasks  Run tasks in background (no panes, logs to file)"
  echo "        --workdir, -w     Working directory for OpenCode"
  echo "        --agent           Agent to use (default: general)"
  echo "        --model, -m       Model to use (default: claude-opus-4-5)"
  echo "        --poll-interval N Poll interval in seconds (default: 30)"
  echo "        --brain-dir       Brain directory (default: ~/docs/brain)"
  echo "        --dry-run         Don't spawn OpenCode, just log"
  echo ""
  echo -e "    ${BOLD}Parallel Execution:${RESET}"
  echo "        --max-parallel, -p N    Max concurrent tasks (default: 3)"
  echo "        --task-poll-interval N  Interval to check task completion (default: 5s)"
  echo ""
  echo "    stop [project-id]     Stop monitor(s)"
  echo "    status [project-id]   Show status with dependency summary"
  echo "    logs [-f]             Show logs (-f to follow)"
  echo ""
  echo -e "${BOLD}QUERY COMMANDS:${RESET}"
  echo "    list <project-id>     List all tasks grouped by status"
  echo "    ready <project-id>    List tasks ready to execute (deps met)"
  echo "    waiting <project-id>  List tasks waiting on dependencies"
  echo "    blocked <project-id>  List blocked tasks"
  echo "    graph <project-id>    Show dependency graph visualization"
  echo "    projects              List all discovered projects"
  echo ""
  echo "    Use --all or -a to query across all projects:"
  echo "        $SCRIPT_NAME list --all"
  echo "        $SCRIPT_NAME ready -a"
  echo ""
  echo -e "${BOLD}MULTI-PROJECT MONITORING:${RESET}"
  echo "    Use 'all' as project-id to monitor all discovered projects."
  echo "    Projects are discovered by scanning ~/docs/brain/projects/*/task"
  echo ""
  echo "    --exclude, -e PATTERN  Exclude projects matching glob pattern"
  echo "                           (can be specified multiple times)"
  echo ""
  echo -e "${BOLD}PARALLEL EXECUTION:${RESET}"
  echo "    Tasks with met dependencies run concurrently (up to --max-parallel)."
  echo "    Each task gets its own horizontal tmux pane in the dashboard."
  echo "    As tasks complete, new ready tasks are spawned automatically."
  echo "    In multi-project mode, the parallel limit applies globally."
  echo ""
  echo -e "${BOLD}DEPENDENCY RESOLUTION:${RESET}"
  echo "    Tasks with depends_on in frontmatter are only processed when all"
  echo "    dependencies are completed. The monitor continuously re-evaluates"
  echo "    dependencies after each task completes."
  echo ""
  echo "    Task states: ready, waiting, blocked, circular"
  echo ""
  echo "    Note: Dependencies only work within a single project"
  echo "    (no cross-project dependencies)."
  echo ""
  echo -e "${BOLD}EXAMPLES:${RESET}"
  echo "    # Run one task (default: visible in tmux pane, auto-completes)"
  echo "    $SCRIPT_NAME run-one test"
  echo ""
  echo "    # Run one task with interactive TUI (requires manual close)"
  echo "    $SCRIPT_NAME run-one test --tui"
  echo ""
  echo "    # Run one task completely in background (no visibility)"
  echo "    $SCRIPT_NAME run-one test --background"
  echo ""
  echo "    # Run one task from any project"
  echo "    $SCRIPT_NAME run-one --all"
  echo "    $SCRIPT_NAME run-one all"
  echo ""
  echo "    # Run one task, skip interrupted tasks"
  echo "    $SCRIPT_NAME run-one test --no-resume"
  echo ""
  echo "    # Run one task with full dashboard window"
  echo "    $SCRIPT_NAME run-one test --dashboard"
  echo ""
  echo "    # Start continuous monitor (default: visible panes, auto-complete)"
  echo "    $SCRIPT_NAME start test"
  echo ""
  echo "    # Start monitor with interactive TUI for each task"
  echo "    $SCRIPT_NAME start test --tui"
  echo ""
  echo "    # Start monitor with tasks running in background (no panes)"
  echo "    $SCRIPT_NAME start test --background-tasks"
  echo ""
  echo "    # Start with 5 concurrent tasks"
  echo "    $SCRIPT_NAME start test --max-parallel 5"
  echo ""
  echo "    # Monitor all projects"
  echo "    $SCRIPT_NAME start all"
  echo ""
  echo "    # Monitor all except test projects"
  echo "    $SCRIPT_NAME start all --exclude 'test-*' --exclude '*-test'"
  echo ""
  echo "    # List all discovered projects"
  echo "    $SCRIPT_NAME projects"
  echo ""
  echo "    # Show ready tasks from all projects"
  echo "    $SCRIPT_NAME ready all"
  echo "    $SCRIPT_NAME ready --all"
  echo ""
  echo "    # Show dependency graph"
  echo "    $SCRIPT_NAME graph test"
  echo ""
  echo "    # List what's ready to run"
  echo "    $SCRIPT_NAME ready test"
  echo ""
  echo -e "${BOLD}ENVIRONMENT:${RESET}"
  echo "    DO_WORK_POLL_INTERVAL       Poll interval for new tasks (default: 30)"
  echo "    DO_WORK_MAX_PARALLEL        Max concurrent tasks (default: 3)"
  echo "    DO_WORK_TASK_POLL_INTERVAL  Task completion check interval (default: 5)"
  echo "    DO_WORK_BRAIN_DIR           Brain directory"
  echo "    DO_WORK_MODEL               Model to use"
  echo ""
  echo -e "${BOLD}VERSION:${RESET}"
  echo "    ${VERSION}"
}

# =============================================================================
# Main
# =============================================================================

main() {
  ensure_dirs
  load_config
  
  local command="${1:-help}"
  shift || true
  
  case "$command" in
    start)
      cmd_start "$@"
      ;;
    run-one|runone|one)
      cmd_run_one "$@"
      ;;
    stop)
      cmd_stop "$@"
      ;;
    status)
      cmd_status "$@"
      ;;
    logs)
      cmd_logs "$@"
      ;;
    tail)
      cmd_logs -f "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    ready)
      cmd_ready "$@"
      ;;
    waiting)
      cmd_waiting "$@"
      ;;
    blocked)
      cmd_blocked "$@"
      ;;
    graph)
      cmd_graph "$@"
      ;;
    projects)
      cmd_projects "$@"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    version|--version|-v)
      echo "$SCRIPT_NAME version $VERSION"
      ;;
    *)
      die "Unknown command: $command. Use '$SCRIPT_NAME help' for usage."
      ;;
  esac
}

main "$@"
